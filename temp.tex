\documentclass[a4paper,landscape,twocolumn]{ctexart}
\usepackage[Glenn]{fncychap}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{lastpage}
\usepackage{ctex}
\usepackage{relsize}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epigraph}
\usepackage{expdlist}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{etoolbox}
\usepackage{xstring}

%\setmainfont{LXGW WenKai}
%\setmainfont{Source Han Serif CN SemiBold}
%\setmathrm{Source Han Serif CN SemiBold}
%\setmathsf{Source Han Serif CN SemiBold}
%\setmathtt{Source Han Serif CN SemiBold}
\setsansfont{WenQuanYi Micro Hei}
\setmonofont{JetBrains Mono NL}
\setCJKmonofont{WenQuanYi Micro Hei Mono}
\setCJKmainfont{Source Han Serif CN}
%\setCJKmainfont{LXGW WenKai}
%\setCJKmainfont{WenQuanYi Micro Hei}

\geometry{left=1cm,right=1cm,top=1.5cm,bottom=1.5cm}

%\renewcommand{\normalsize}{\fontsize{10}{10}\selectfont}

\def\KWauthor{frost\_ice @ HEU}
\def\KWtitle{Code Template}

\title{\textlarger[10]{\KWtitle}}
\author{\KWauthor}
%\date{2024年12月}

% 定义目录格式
\makeatletter
\renewcommand\tableofcontents{%
	\section*{\makebox[\linewidth][c]{\contentsname}%
		\@mkboth{\MakeUppercase\contentsname}{\MakeUppercase\contentsname}}%
	\begin{multicols}{3}%
		\@starttoc{toc}%
	\end{multicols}
}
\makeatother

\setminted{
    fontsize=\footnotesize,
	fontfamily=tt,
	baselinestretch=1,
	linenos=true,
    numbers=left,
    numberblanklines=true,
    stepnumber=1,
    numbersep=2pt,
    frame=single,
    rulecolor=\color{black},
	xleftmargin=15pt,
	% tab 相关设置
	showtabs=true,
    tabsize=2,
	tab=$\mid$\space,
	% 换行
    breaklines=true,
	breakafter={.,\space,-,/,\#,\{,\},\%,[,],\,},
    breakaftersymbolpost=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookrightarrow}\space},
	breakaftersymbolpre={},
	breaksymbolleft={},
	breaksymbolright={},
%    escapeinside=@@,
}

\setminted[cpp]{
	extrakeywordsreserved={REP,REV,*,...},
	extrakeywordstype={i64,u64,i32,u32,array,set,vector,*,...},
}

\setmintedinline{bgcolor={}}
\usemintedstyle{xcode}


% 1. 定义一个映射表，把“行号索引”映射到“自定义标签”
%    这里我们用宏名 CustomLabel@<n> 存储第 n 行的标签
\newcommand\DefineCustomLabel[2]{%
  % #1=行索引，#2=标签文本
  \expandafter\gdef\csname CustomLabel@#1\endcsname{#2}%
}

% 在导言区把需要的标签都“加载”进来
% 若有更多行，可继续 \DefineCustomLabel{3}{xxx}、\DefineCustomLabel{4}{yyy} …

% 2. 重定义 minted 内部的行号打印命令
\makeatletter
\renewcommand{\theFancyVerbLine}{{%
 \color{gray}%
    % LaTeX 内置的行号计数器是 FancyVerbLine
    \edef\curIdx{\arabic{FancyVerbLine}}%
    % 尝试取出 CustomLabel@\curIdx，如果不存在就退回数字
    \ifcsdef{CustomLabel@\curIdx}{%
      \csuse{CustomLabel@\curIdx}%
    }{%
      \curIdx%
    }%
  }%
}
\makeatother

\begin{document}

\newgeometry{left=1cm,right=1cm,top=1.5cm,bottom=1.5cm}
\begin{titlepage}
\thispagestyle{plain}
\thispagestyle{empty}
\begin{center}
	~\\[100pt]
	\hrule\ \\[8pt]
	\fontsize{48pt}{\baselineskip}\selectfont  \textsc{\KWtitle}\\[8pt]
	~\\[20pt]
%		\includegraphics[scale=1]{./cover.jpg}
	~\\[70pt]
	\huge \KWauthor\\[8pt]
	\Large Last build at \today
	~\\[80pt]
	\hrule\ \\[8pt]
\end{center}
\pagebreak
%\pagestyle{plain}
\pagestyle{fancy}
\lhead{}
\rhead{}
\chead{\KWtitle, \KWauthor}
\cfoot{}
\tableofcontents
\end{titlepage}
\restoregeometry

\pagestyle{fancy}

\pagestyle{fancy}
\lhead{\large\KWtitle, \KWauthor}
\chead{}
\rhead{\Huge\bfseries\thepage}
\lfoot{}
\cfoot{第 \thepage 页 - 共 \pageref{LastPage} 页}
\rfoot{}

\section{数论}

\subsection{ExGcd}

% \begin{minted}{cpp}
% i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {
% 	if (b == 0) { x = 1, y = 0; return a; }
% 	i64 d = exgcd(b, a % b, y, x);
% 	y -= a / b * x; return d;
% }
% \end{minted}


\begin{minted}{cpp}
// result : -b < x < b AND -a < y <= a when a,b != 0
array<i64, 3> exgcd(i64 a, i64 b) {
	if (!b) return {a, 1, 0};
	auto [d, x, y] = exgcd(b, a % b);
	return {d, y, x - y * (a / b)};
}
\end{minted}

\subsection{exCRT}

\begin{minted}{cpp}
array<i64, 2> exCRT(i64 a1, i64 p1, i64 a2, i64 p2) {
	auto [g, a, b] = exgcd(p1, p2);
	if ((a1 - a2) % g) return {-1, 0};
	i64 k = __int128((a2 - a1) % p2 + p2) * (a + p2) % p2;
	return {p1 / g * k + a1, p1 / g * p2};
}
\end{minted}

\subsection{euler\_phi}

\begin{minted}{cpp}
int euler_phi(int n) {
	int ans = n;
	for (int i = 2; i * i <= n; i++)
		if (n % i == 0) {
			ans = ans / i * (i - 1);
			while (n % i == 0) n /= i;
		}
	if (n > 1) ans = ans / n * (n - 1);
	return ans;
}
\end{minted}

\subsection{预处理逆元}

\begin{minted}{cpp}
inv[1] = 1; REP(i, 2, n) inv[i] = u64(mod - mod / i) * inv[mod % i] % mod;
\end{minted}

%\subsection{线性筛}
%
%标记 \texttt{vis} 了吗？该 \texttt{break} 的地方 \texttt{break} 了吗？

%
%\begin{minted}{cpp}
% const int N = 1e5+10;
% bitset<N> vis;
% vector<int> primes;
% // Mobius函数, 欧拉函数
% int mu[N], phi[N];
% // 约数个数, 最小质因子数量
% int d[N], num[N];
% // 约数和, 最小质因子的p^0+p^1+...+p^k
% int f[N], g[N];
% static inline void Init(int n) {
% 	vis[1] = 1;
% 	mu[1] = 1;
% 	phi[1] = 1;
% 	d[1] = 1, num[1] = 0;
% 	g[1] = f[1] = 1;
% 	for (int i = 2; i <= n; i ++) {
% 		if (!vis[i]) {
% 			primes.push_back(i);
% 			mu[i] = -1;
% 			phi[i] = i-1;
% 			num[i] = 1, d[i] = 2;
% 			g[1] = f[1] = i+1;
% 		}
% 		for (auto j : primes) {
% 			if (i*j > n) break;
% 			vis[i*j] = 1;
% 			mu[i*j] = -mu[i];
% 			phi[i*j] = phi[i]*phi[j];
% 			num[i*j] = 1, d[i*j] = d[i]<<1;
% 			g[i*j] = j+1, f[i*j] = f[i]*f[j];
% 			if (i%j == 0) {
% 				mu[i*j] = 0;
% 				phi[i*j] = phi[i]*j;
% 				num[i*j] = num[i]+1, d[i*j] = d[i] / (num[i]+1) * (num[i]+2);
% 				g[i*j] = g[i]*j+1, f[i*j] = f[i] / g[i] * g[i*j];
% 				break;
% 			}
% 		}
% 	}
% }
%\end{minted}

\subsection{常见数论函数}

\begin{itemize}
\item $\mathrm{\epsilon}$ 函数（单位函数）：$\mathrm{\epsilon} (p ^ \alpha) = 0$；
\item $\mathrm{I}$ 函数：$\mathrm{I} (p ^ \alpha) = 1$；
\item $\mathrm{id}_t$ 函数：$\mathrm{id}_t (p ^ \alpha) = p ^ {\alpha t}$；
\item $\mathrm{\mu}$ 函数：$\mathrm{\mu} (p ^ \alpha) = - \left [ \alpha = 1 \right ]$；
\item $\mathrm{\phi}$ 函数：$\mathrm{\phi} (p ^ \alpha) = (p - 1) p ^ {\alpha - 1}$；
\item $\mathrm{d}$ 函数（约数个数）：$\mathrm{d} (p ^ \alpha) = \alpha + 1$；
\item $\mathrm{\sigma}_1$ 函数（约数和）：$\mathrm{\sigma}_1 (p ^ \alpha) = \sum_{i = 0}^{\alpha} p ^ i$；
\item 【非积性/加性】$\Lambda$ 函数：$\Lambda (p ^ \alpha)$（$\alpha \geq 1$）为 $\log p$，其余均为 $0$。
\end{itemize}

\subsection{Miller–Rabin + Pollard-rho}

\begin{minted}{cpp}
i64 mul(i64 a, i64 b, i64 p) {
	i64 z = a * (db(1) / p) * b + 0.5L, res = a * b - z * p;
	return res + (res >> 63 & p);
}
i64 qpow(i64 x, i64 y, i64 p, i64 res = 1) {
	for (; y; y >>= 1, x = mul(x, x, p))
		if (y & 1) res = mul(res, x, p);
	return res;
}
int MR(i64 p) {
	if (p == 1) return 0;
	i64 d = __builtin_ctzll(p - 1), s = (p - 1) >> d;
	for (auto a : {2, 3, 5, 7, 11, 13, 82, 373}) {
		if (a % p == 0) continue;
		i64 y, x = qpow(a, s, p);
		for (int i = 0; i < d; ++i, x = y) {
			y = mul(x, x, p);
			if (y == 1 && x != 1 && x != p - 1)
				return 0;
		}
		if (x != 1) return 0;
	}
	return 1;
}
i64 PR(i64 p) { // p > 1 && not prime
	if (!(p & 1)) return 2;
	i64 x = 0, y = 0, pp = 1;
	auto f = [p](i64 o) { return mul(o, o, p) + 1; };
	for (int t = 30, z = 0; t % 64 || gcd(pp, p) == 1; t ++) {
		if (x == y) x = ++z, y = f(x);
		if (i64 q = mul(pp, x + p - y, p)) pp = q;
		x = f(x), y = f(f(y));
	}
	return gcd(pp, p);
}
\end{minted}

\subsection{Mod Int}

\begin{minted}{cpp}
constexpr int mod = 998'244'353;
constexpr int qpow(int x, int y, int m = mod, int ans = 1) {
	for (; y; y >>= 1, x = (u64) x * x % m)
		if (y & 1) ans = (u64) ans * x % m;
	return ans; }
constexpr int Normal(i64 x, int m = mod) { return x%=m, x<0&&(x+=m), x; }
struct Mint { int val; constexpr Mint(i64 x = 0) : val(Normal(x)) {} };
constexpr Mint Pow(Mint a, i64 p) { return qpow(a.val, Normal(p, mod-1)); }
constexpr Mint Inv(Mint a) { return Pow(a, -1); }
constexpr Mint operator- (Mint a) { return mod - a.val; }
constexpr Mint operator+ (Mint a, Mint b) { return a.val + b.val; }
constexpr Mint operator- (Mint a, Mint b) { return a.val - b.val; }
constexpr Mint operator* (Mint a, Mint b) { return (u64) a.val * b.val; }
constexpr Mint operator/ (Mint a, Mint b) { return a * Inv(b); }
constexpr Mint& operator+= (Mint &a, Mint b) { return a = a + b; }
constexpr Mint& operator-= (Mint &a, Mint b) { return a = a - b; }
constexpr Mint& operator*= (Mint &a, Mint b) { return a = a * b; }
constexpr Mint& operator/= (Mint &a, Mint b) { return a = a / b; }
constexpr Mint& operator++ (Mint &a) { return a += 1; }
constexpr Mint& operator-- (Mint &a) { return a -= 1; }
constexpr Mint operator++ (Mint &a, int) { auto b = a; return a += 1, b; }
constexpr Mint operator-- (Mint &a, int) { auto b = a; return a -= 1, b; }
template <typename S> S& operator<< (S &s, Mint a) { return s << a.val; }
constexpr bool operator== (Mint a, Mint b) { return a.val == b.val; }
constexpr Mint operator "" _M (unsigned long long x) { return x % mod; }
\end{minted}

\subsection{二次剩余}

\begin{minted}{cpp}
array<int, 2> res2(int n, int p) {
	if (!n) return {0, 0};
	if (qpow(n, p / 2, p) != 1) return {-1, -1};
	int t, ii; static mt19937_64 rnd(114514);
	do t = rnd() % p, ii = ((u64) t * t + p - n) % p;
	while (qpow(ii, p / 2, p) != p - 1);
	array<int, 2> ans = {1, 0}, x = {t, 1};
	auto mul = [&] (array<int,2> x, array<int,2> y)->array<int,2> {
		return {int(((u64) x[0] * y[0] + (u64) x[1] * y[1] % p * ii)%p),
				int(((u64) x[0] * y[1] + (u64) x[1] * y[0]) % p)}; };
	for (int y = p / 2 + 1; y; y >>= 1, x = mul(x, x))
		if (y & 1) ans = mul(ans, x);
	return {min(ans[0], p - ans[0]), max(ans[0], p - ans[0])};
}
\end{minted}

\subsection{Poly}

\begin{minted}{cpp}
constexpr int mod = 998'244'353;
constexpr int qpow(int x, int y, int m = mod, int ans = 1) {
	for (; y; y >>= 1, x = (u64) x * x % m)
		if (y & 1) ans = (u64) ans * x % m;
	return ans;
}
using P = vector<int>;
vector<int> rev, wn;
int lim, invlim;
void init(int n) {
	lim = max(2 << __lg(n - 1), 1);
	invlim = mod - (mod - 1) / lim;
	if (lim > wn.size()) wn.resize(lim);
	rev.resize(lim);
	for (static int i = 1; i < lim; i <<= 1) {
		int w = qpow(3, mod / i / 2), cur = 1;
		for (int j = 0; j < i; j ++)
			wn[i+j] = cur, cur = (u64) cur * w % mod;
	}
	REP(i, 1, lim-1) rev[i] = rev[i>>1] >> 1 | (i&1 ? lim>>1 : 0);
}
P trunc(const P &a, int siz) {
	if (siz <= a.size()) return P(a.begin(), a.begin() + siz);
	P res = a; res.resize(siz); return res;
}
P reverse(const P &v) { return P(v.rbegin(), v.rend()); }
P dft(const P &a) {
	static vector<u64> tmp;
	tmp.assign(lim, 0);
	REP(i, 0, a.size()-1) tmp[rev[i]] = a[i];
	for (int i = 1; i < lim; i <<= 1) {
		for (int k = i & (1 << 19); k--; )
			if (tmp[k] >= mod * 9ull) tmp[k] -= mod * 9ull;
		for (int j = 0; j < lim; j += 2 * i)
			for (int k = 0; k < i; k ++) {
				const u64 x = (u64) tmp[i+j+k] * wn[i+k] % mod;
				tmp[i+j+k] = tmp[k+j] + mod - x; tmp[k+j] += x;
			}
	}
	REP(i, 0, lim-1) tmp[i] %= mod;
	return P(tmp.begin(), tmp.end());
}
P idft(const P &a) {
	auto b = dft(a); reverse(b.begin()+1, b.end());
	for (auto &i : b) i = (u64) i * invlim % mod;
	return b;
}
P operator- (const P &a) {
	P c = a;
	for (auto &i : c) i = i ? mod - i : 0;
	return c;
}
P operator+ (const P &a, const P &b) {
	P c(max(a.size(), b.size()));
	REP(i, 0, a.size()-1) c[i] += a[i];
	REP(i, 0, b.size()-1) c[i] += b[i], c[i] >= mod && (c[i] -= mod);
	return c;
}
P operator- (const P &a, const P &b) {
	return a + (-b);
}
P operator* (const P &a, const P &b) {
	assert(a.size() && b.size());
	int l = a.size() + b.size() - 1;
	init(l);
	auto c = dft(a), d = dft(b);
	REP(i, 0, lim-1) c[i] = (u64) c[i] * d[i] % mod;
	auto res = idft(c);
	return trunc(res, l);
}
P operator* (const P &a, int b) {
	auto x = trunc(a, a.size());
	for (auto &i : x) i = (u64) i * b % mod;
	return x;
}
P inv(const P &a) { // inv(a) (mod x^n)
	int n = a.size();
	P x = {qpow(a[0], mod-2)};
	for (int t = 2; t < 2 * n; t <<= 1)
		x = trunc((P {2} - trunc(a, t) * x) * x, t);
	return trunc(x, n);
}
pair<P, P> div(const P &f, const P &g) { // f = g * q + r
	int n = f.size(), m = g.size();
	auto q = reverse(trunc(reverse(f) * inv(trunc(reverse(g), n-m+1)), n-m+1));
	auto r = trunc(f - g * q, m - 1);
	return {q, r};
}
P sqrt(const P &a) { // sqrt(a) (mod x^n);
	P b {res2(a[0], mod)[0]};
	if (b[0] < 0) return {};
	int n = a.size();
	for (int t = 2; t < 2 * n; t <<= 1)
		b = trunc((trunc(a, t) + b * b) * inv(trunc(b * 2, t)), t);
	return trunc(b, n);
}
P deriv(const P &a) {
	int n = a.size(); if (!n) return {}; P res(n - 1);
	REP(i, 0, n-2) res[i] = (u64) a[i + 1] * (i + 1) % mod;
	return res;
}
P integr(const P &a) {
	int n = a.size(); P res(n + 1);
	REP(i, 1, n) res[i] = (u64) a[i - 1] * qpow(i, mod-2, mod) % mod;
	return res;
}
P log(const P &a) {
	return trunc(integr(deriv(a) * inv(a)), a.size());
}
P exp(const P &a) {
	int n = a.size(); P b {1};
	for (int t = 2; t < 2 * n; t <<= 1)
		b = trunc(b * (P {1} - log(trunc(b, t)) + trunc(a, t)), t);
	return trunc(b, n);
}
\end{minted}

\section{数学}

\subsection{素勾股数}

\begin{minted}{cpp}
void gen(int a, int b, int c) {
    gen( a + 2 * b + 2 * c,  2 * a + b + 2 * c,  2 * a + 2 * b + 3 * c);
    gen(-a + 2 * b + 2 * c, -2 * a + b + 2 * c, -2 * a + 2 * b + 3 * c);
    gen( a - 2 * b + 2 * c,  2 * a - b + 2 * c,  2 * a - 2 * b + 3 * c);
} // 用法: gen(3, 4, 5) 遍历所有 a < b 的素勾股数
\end{minted}

\subsection{组合数}

\begin{minted}{cpp}
int fac[N], inv[N];
static inline void Init(i64 n) {
	fac[0] = 1;
	REP(i, 1, n) fac[i] = (u64) fac[i-1] * i % mod;
	inv[n] = qpow(fac[n], mod - 2);
	REV(i, n, 1) inv[i-1] = (u64) inv[i] * i % mod;
}
static inline i64 C(i64 x, i64 y) {
	if (y > x || y < 0) return 0;
	return (u64) fac[x] * inv[y] % mod * inv[x-y] % mod;
}
\end{minted}

\subsection{组合数学相关}
\begin{itemize}
\begin{minted}{cpp}
inline i64 calc(i64 p, i64 m, i64 k, i64 i) { // c[p]中 i个元素>=k的方案数
	if (i * k > m || i > p) return 0;
	return (C(p,i)*C(m-i*k+p-1,p-1)+mod-calc(p,m,k,i+1))%mod;
}
\end{minted}
\item 第二类斯特林数
$$
St2 (n, m)
= \sum_{i = 0}^{m} \frac{ \left ( -1 \right ) ^ {m - i} i ^ n}{ i ! \left ( m - i \right ) ! }
$$
\item 卡特兰数
$$
H_n
= \frac{C (2 n, n)}{n + 1}
= \frac{(4 n - 2) H_{n-1}}{n + 1}
= C(2 n, n) - C (2 n, n - 1)
$$
\item 小球装盒问题
\begin{tabular}{|c|c|c|c|}
	\hline
	k 个球 & m 个盒子 & 允许有空 & 方案数 \\
	\hline
	\multirow{4}{*}[0em]{各不相同} & \multirow{2}{*}[0em]{各不相同} & 是 & $m ^ k$ \\
	\cline{3-4}
	& & 否 & $m ! \cdot St2 (k, m)$ \\
	\cline{2-4}
	& \multirow{2}{*}[0em]{完全相同} & 是 & $\sum_{i=1}^{m} {St2 (k, i)}$ \\
	\cline{3-4}
	& & 否 & $St2 (k, m)$ \\
	\hline
	\multirow{4}{*}[0em]{完全相同} & \multirow{2}{*}[0em]{各不相同} & 是 & $C (m + k - 1, m-1)$ \\
	\cline{3-4}
	& & 否 & $C (k-1, m-1)$ \\
	\cline{2-4}
	& \multirow{2}{*}[0em]{完全相同} & 是 & $[x^k] \prod_{i=1}^{m} \frac{1}{1 - x ^ i}$ \\
	\cline{3-4}
	& & 否 & $ [x^k] \prod_{i=1}^{m} \frac{x ^ m}{1 - x ^ i} $ \\
	\hline
\end{tabular}
\end{itemize}

\subsection{FFT}

\begin{minted}{cpp}
using cp = complex<db>;
// cp::real  cp::imag  std::conj  std::arg
const db PI = acos(-1.L);
int rev[N], lim; cp wn[N];
void init(int siz) {
	lim = 2 << __lg(siz - 1);
	for (static int i = 1; i < lim; i <<= 1)
		for (int j = 0; j < i; j ++)
			wn[i+j] = polar(1.L, db(j) / db(i) * PI);
	for (int i = 1; i < lim; i ++)
		rev[i] = rev[i>>1] >> 1 | (i & 1 ? lim >> 1 : 0);
}
void dft(cp* a) {
	for (int i = 0; i < lim; i ++)
		if (rev[i] < i) swap(a[rev[i]], a[i]);
	for (int i = 1; i < lim; i <<= 1)
		for (int j = 0; j < lim; j += 2*i)
			for (int k = 0; k < i; k ++) {
				cp x = a[k+j] - a[i+j+k] * w[i+k];
				cp y = a[k+j] + a[i+j+k] * w[i+k];
				a[i+j+k] = x, a[k+j] = y;
			}
}
void idft(cp* a) {
	dft(a); reverse(a+1, a+lim);
	for (int i = 0; i < lim; i ++) a[i] /= lim;
}
\end{minted}

\subsection{FMT / 或卷积}

\begin{minted}{cpp}
void fmt(int* a) { // n = 1 << d
	REP(i, 0, d-1) REP(j, 0, n-1) if (1<<i&j)
		a[j] += a[j^(1<<i)];
}// ifmt: a[j] -= a[j^(1<<i)];
\end{minted}

\subsection{子集卷积}

\begin{minted}{cpp}
// n = 1 << d;
// in: a/b[__builtin_popcount(i)][i];
REP(i, 0, d) fmt(a[i]), fmt(b[i]);
REP(i, 0, n-1) REP(j, 0, d) REP(k, 0, d-j)
	c[j+k][i] += 1ll * a[j][i] * b[k][i];
REP(i, 0, d) ifmt(c[i]);
// out: c[__builtin_popcount(i)][i]
\end{minted}

\subsection{FWT}

\begin{minted}{cpp}
constexpr array<Mint, 4> OR1  = {    1,     0,     1,      1};
constexpr array<Mint, 4> OR2  = {    1,     0,    -1,      1};
constexpr array<Mint, 4> AND1 = {    1,     1,     0,      1};
constexpr array<Mint, 4> AND2 = {    1,    -1,     0,      1};
constexpr array<Mint, 4> XOR1 = {    1,     1,     1,     -1};
constexpr array<Mint, 4> XOR2 = {1_M/2, 1_M/2, 1_M/2, -1_M/2};
constexpr void FWT(int n, Mint* a, array<Mint, 4> t) {
	for (int k = 1; k < n; k <<= 1) {
		for (int i = 0; i < n; i += k * 2) {
			for (int j = 0; j < k; j++) {
				auto tmp0 = a[i+j] * t[0] + a[i+j+k] * t[1];
				auto tmp1 = a[i+j] * t[2] + a[i+j+k] * t[3];
				a[i + j] = tmp0, a[i + j + k] = tmp1;
			}
		}
	}
}
\end{minted}

\section{二维计算几何}

\subsection{凸包}

\begin{minted}{cpp}
using pt = array<i64, 2>;
pt operator+ (pt a, pt b) { return {a[0] + b[0], a[1] + b[1]}; }
pt operator- (pt a, pt b) { return {a[0] - b[0], a[1] - b[1]}; }
i64 operator* (pt a, pt b) { return a[0] * b[0] + a[1] * b[1]; }
i64 operator^ (pt a, pt b) { return a[0] * b[1] - a[1] * b[0]; }
pt operator- (pt a) { return {-a[0], -a[1]}; }
db abs(pt a) { return __builtin_hypot(a[0], a[1]); }
i64 sq(pt a) { return a[0] * a[0]+ a[1] * a[1]; }
int check(pt x, pt y, pt z) { return ((y - x) ^ (y - z)) < 0; }
vector<int> work(const vector<pt> &p) {
	if (!p.size()) return {};
	int n = p.size(), top = -1;
	vector<int> ind(n), st(n+1), vis(n);
	REP(i, 0, n-1) ind[i] = i;
	ranges::sort(ind, [&] (int i, int j) { return p[i] < p[j]; });
	st[++top] = ind[0];
	REP(i, 0, n-1) {
		while (top >= 1 && !check(p[st[top-1]], p[st[top]], p[ind[i]]))
			vis[st[top]] = 0, top --;
		st[++top] = ind[i]; vis[ind[i]] = 1;
	}
	int siz = top;
	REV(i, n-2, 0) {
		if (vis[ind[i]]) continue;
		while (top > siz && !check(p[st[top-1]], p[st[top]], p[ind[i]]))
			vis[st[top]] = 0, top --;
		st[++top] = ind[i]; vis[ind[i]] = 1;
	}
	return st.resize(top), st;
}
\end{minted}

%\section{字符串}
%
%\subsection{manacher}
%
%\begin{minted}{cpp}
%void manacher(int sz) {
%	int R = 0, mid = 0;
%	REP(i, 1, sz-1) {
%		p[i] = R > i ? min(p[2*mid-i], R-i) : 1;
%		while (s1[i+p[i]] == s1[i-p[i]]) p[i]++;
%		if (i + p[i] > R) R = i + p[i], mid = i;
%	}
%}
%int is_pal(int l, int r) { return p[l+r] > r - l; }
%/*
%0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M [index]
%  1   1   1   1   1   11  1   1   1   1   1
%^ . a . b . c . b . a . a . b . c . b . a . @
%    2   2   6   2   2   2   2   6   2   2
%*/
%\end{minted}

\section{数据结构}

\subsection{区间加和树状数组}

\begin{minted}{cpp}
void Add(i64 p, i64 v) { // 后缀加
	for (int x = p; x <= n; x += x&-x)
		ta[x] += v, tb[x] += p * v;
} // [l, r] ==> Add(l, v); Add(r+1, -v);
i64 Query(i64 p, i64 ans = 0) { // 前缀求和
	for (int x = p; x; x -= x&-x)
		ans += (p+1) * ta[x] - tb[x];
	return ans;
} // [l, r] ==> Query(r) - Query(l-1);
\end{minted}

\subsection{二维树状数组}

维护四个普通二维树状数组 $T_0$、$T_1$、$T_2$、$T_3$：

\begin{itemize}
\item 后缀 $(x, y) \sim \cdots$ 加：在 $(x, y)$ 单点加，修改量分别乘 $1$、$x$、$y$、$x \times y$。
\item 前缀 $(1, 1) \sim (x, y)$ 求和：查询 $(x, y)$ 前缀和，结果分别乘 $(x \times y + x + y + 1)$、$(-y - 1)$、$(-x - 1)$、$1$ 并求和。
\end{itemize}

%\begin{minted}{cpp}
%struct T {
%	int tr[N][N];
%	void Add(int p, int q, int v) {
%		for (int x = p; x <= n; x += x&-x)
%		for (int y = q; y <= n; y += y&-y)
%		tr[x][y] += v;
%	}
%	int Query(int p, int q, int ans = 0) {
%		for (int x = p; x >= 1; x -= x&-x)
%		for (int y = q; y >= 1; y -= y&-y)
%		ans += tr[x][y];
%		return ans;
%	}
%} T, Tx, Txy, Ty;
%void Add(int x, int y, int v) {
%	T.Add(x, y, v);
%	Tx.Add(x, y, v * x);
%	Ty.Add(x, y, v * y);
%	Txy.Add(x, y, v * x * y);
%}
%int Query(int x, int y) {
%	return Txy.Query(x, y)
%	- Tx.Query(x, y) * (y + 1)
%	- Ty.Query(x, y) * (x + 1)
%	+ T.Query(x, y) * (x*y + x + y + 1);
%}
%// (a, b) ~ (c, d)
%void A(int a, int b, int c, int d, int v) {
%	c ++, d ++;
%	Add(c, d, v); Add(a, b, v); Add(a, d, -v); Add(c, b, -v);
%}
%int Q(int a, int b, int c, int d) {
%	a --, b --;
%	return Query(c, d) + Query(a, b) - Query(a, d) - Query(c, b);
%}
%\end{minted}

\subsection{树状数组二分}

\begin{minted}{cpp}
// 最后一个 前缀和 <= k 的位置
int select(int k) {
	int x = 0, cur = 0;
	for (int i = 1<<__lg(n); i; i /= 2)
		if (x + i <= n && cur + tree[x+i] <= k)
			x += i, cur = cur + tree[x];
	return x;
}
\end{minted}

\subsection{单点修改线段树}

\begin{minted}{cpp}
struct Info { };
Info operator+ (const Info &a, const Info &b) {}
Info info[N<<2], init[N];
inline void PushUp(int x) { info[x] = info[x<<1] + info[x<<1|1]; }
inline void Build(int x, int l, int r) {
	if (l >= r) return info[x] = init[l], void ();
	int mid = l + (r - l) / 2;
	Build(x<<1, l, mid);
	Build(x<<1|1, mid+1, r);
	PushUp(x);
}
inline void Modify(int x, int l, int r, int pos, const Info &val) {
	if (l == pos && pos == r) return info[x] = val, void ();
	int mid = l + (r - l) / 2;
	if (pos <= mid) Modify(x<<1, l, mid, pos, val);
	if (pos > mid) Modify(x<<1|1, mid+1, r, pos, val);
	PushUp(x);
}
inline Info Query(int x, int l, int r, int L, int R) {
	if (L <= l && r <= R) return info[x];
	int mid = l + (r - l) / 2;
	if (R <= mid) return Query(x<<1, l, mid, L, R);
	if (mid < L) return Query(x<<1|1, mid+1, r, L, R);
	return Query(x<<1, l, mid, L, R) + Query(x<<1|1, mid+1, r, L, R);
}
\end{minted}

\subsection{区间修改懒标记线段树}

\begin{minted}{cpp}
struct Tag {
	void apply(const Tag &t) {}
	static Tag Id() {}
};
struct Info {
	void apply(const Tag &t) {}
};
Info operator+ (const Info &a, const Info &b) {}
Info info[N<<2], init[N]; Tag tag[N<<2];
inline void PushUp(int x) {
	info[x] = info[x<<1] + info[x<<1|1];
}
inline void Apply(int x, const Tag &val) {
	info[x].apply(val); tag[x].apply(val);
}
inline void PushDown(int x) {
	Apply(x<<1, tag[x]); Apply(x<<1|1, tag[x]); tag[x] = Tag::Id();
}
inline void Build(int x, int l, int r) {
	tag[x] = Tag::Id();
	if (l >= r) return info[x] = init[l], void ();
	int mid = l + (r - l) / 2; Build(x<<1, l, mid);
	Build(x<<1|1, mid+1, r); PushUp(x);
}
inline void Modify(int x, int l, int r, int pos, const Info &val) {
	if (l == pos && pos == r) return info[x] = val, void ();
	PushDown(x); int mid = l + (r - l) / 2;
	if (pos <= mid) Modify(x<<1, l, mid, pos, val);
	if (pos > mid) Modify(x<<1|1, mid+1, r, pos, val);
	PushUp(x);
}
inline void Add(int x, int l, int r, int L, int R, const Tag &val) {
	if (L <= l && r <= R) return Apply(x, val), void ();
	PushDown(x); int mid = l + (r - l) / 2;
	if (mid >= L) Add(x<<1, l, mid, L, R, val);
	if (R > mid) Add(x<<1|1, mid+1, r, L, R, val);
	PushUp(x);
}
inline Info Query(int x, int l, int r, int L, int R) {
	if (L <= l && r <= R) return info[x];
	PushDown(x); int mid = l + (r - l) / 2;
	if (R <= mid) return Query(x<<1, l, mid, L, R);
	if (mid < L) return Query(x<<1|1, mid+1, r, L, R);
	return Query(x<<1, l, mid, L, R) + Query(x<<1|1, mid+1, r, L, R);
}
\end{minted}

\subsection{ST表}

\begin{minted}{cpp}
int f[N+50][20], n;
void Init() {
	REP(i, 1, __lg(n)) REP(j, 1, n-(1<<i)+1)
		f[j][i] = gcd(f[j][i-1], f[j+(1<<(i-1))][i-1]);
}
int Get(int l, int r) {
	int k = __lg(r-l+1);
	return gcd(f[l][k], f[r-(1<<k)+1][k]);
}
\end{minted}

\subsection{FHQ \space Treap}

\begin{minted}{cpp}
struct Tr { int v, w, ls, rs, siz; } tr[N];
inline void Pushup(int u) {  }
inline void Pushdown(int u) {  }
int Merge(int x, int y) {
	if (!x || !y) return x ^ y;
	if (tr[x].w > tr[y].w)
		return Pushdown(x), tr[x].rs = Merge(tr[x].rs, y), Pushup(x), x;
	return Pushdown(y), tr[y].ls = Merge(x,tr[y].ls), Pushup(y), y;
}
void Split(int u, int v, int &x, int &y) { // 按值: <= w | > w
	if (!u) return x = y = 0, void();
	Pushdown(u);
	if (tr[u].v <= v) x = u, Split(tr[u].rs, v, tr[u].rs, y);
	else y = u, Split(tr[u].ls, v, x, tr[u].ls);
	Pushup(u);
}
void Split(int u, int siz, int &x, int &y) { // 按大小: siz | n-siz
	if (!u) return x = y = 0, void();
	Pushdown(u);
	if (tr[tr[u].ls].siz + 1 > siz) y = u, Split(tr[u].ls, siz, x, tr[u].ls);
	else x = u, Split(tr[u].rs, siz - tr[tr[u].ls].siz - 1, tr[u].rs, y);
	Pushup(u);
}
\end{minted}

\subsection{笛卡尔树}

\begin{minted}{cpp}
int lc[N], rc[N], s[N], n, p;
void build () { // v: i ; w: a[i] ; root=rc[0]
	for (int i = 1;i <= n;++i) { // 大根堆则是 <
		while (p && (a[s[p]] > a[i])) p--;
		lc[i] = rc[s[p]], rc[s[p]] = i, s[++p] = i;
	}
}
\end{minted}

%\subsection{普通矩阵}
%
%\begin{minted}{cpp}
%template <size_t N, size_t M, typename T = i64>
%using Mat = array<array<T, M>, N>;
%
%template <size_t N, size_t M, typename T>
%Mat<N, M, T> operator+ (const Mat<N, M, T> &a, const Mat<N, M, T> &b) {
%	Mat<N, M, T> res {};
%	REP(i, 0, N-1) REP(j, 0, M-1) res[i][j] = a[i][j] + b[i][j];
%	return res;
%}
%template <size_t N, size_t M, typename T>
%Mat<N, M, T> operator- (const Mat<N, M, T> &a, const Mat<N, M, T> &b) {
%	Mat<N, M, T> res {};
%	REP(i, 0, N-1) REP(j, 0, M-1) res[i][j] = a[i][j] - b[i][j];
%	return res;
%}
%template <size_t N, size_t M, size_t K, typename T>
%constexpr Mat<N, K, T> operator* (const Mat<N, M, T> &a, const Mat<M, K, T> &b) {
%	Mat<N, K, T> res {};
%	REP(i, 0, N-1) REP(j, 0, M-1) REP(k, 0, K-1)
%		res[i][k] += a[i][j] * b[j][k];
%	return res;
%}
%\end{minted}

%\subsection{(max, +)矩阵}
%
%\begin{minted}{cpp}
%template <typename Ty>
%constexpr void chmax(Ty &a, Ty b) {
%	if (b > a) a = b;
%}
%template <size_t N, typename T = i64>
%using Mat = array<array<T, N>, N>;
%template <size_t N, typename T>
%constexpr Mat<N, T> operator* (const Mat<N, T> &a, const Mat<N, T> &b) {
%	Mat<N, T> res {};
%	REP(i, 0, N-1) REP(k, 0, N-1) res[i][k] = -1e16;
%	REP(i, 0, N-1) REP(j, 0, N-1) REP(k, 0, N-1)
%		chmax(res[i][k], a[i][j] + b[j][k]);
%	return res;
%}
%\end{minted}

\subsection{LCT}

\begin{minted}{cpp}
const int N = 2e5+10;
int son[N][2], fa[N], rev[N], val[N], sum[N];
bool get(int x, int p = 1) { return son[fa[x]][p] == x; }
void update(int x) {
	sum[x] = val[x] ^ sum[son[x][0]] ^ sum[son[x][1]];
}
int is_root(int x) { return !(get(x) || get(x, 0)); }
void rotate(int x) { // 注意 x y z !!!!!
	int y = fa[x], z = fa[y], b = get(x);
	if (!is_root(y)) son[z][get(y)] = x;
	son[y][b] = son[x][!b], son[x][!b] = y;
	fa[son[y][b]] = y, fa[y] = x, fa[x] = z; update(y);
}
void put(int x) {
	if (x) rev[x] ^= 1, swap(son[x][0], son[x][1]);
}
void down(int x) {
	if (rev[x]) put(son[x][0]), put(son[x][1]), rev[x] = 0;
}
void pushdown(int x) {
	if (!is_root(x)) pushdown(fa[x]);
	down(x);
}
void splay(int x) {
	for (pushdown(x); !is_root(x); rotate(x))
		if (!is_root(fa[x])) rotate(get(x)^get(fa[x]) ? x : fa[x]);
	update(x);
}
void access(int x) {
	for (int t = 0; x; son[x][1] = t, t = x, x = fa[x]) splay(x);
}
void mkroot(int x) {
	access(x), splay(x), put(x);
}
int find(int x) {
	access(x), splay(x);
	while (son[x][0]) x = son[x][0];
	return splay(x), x;
}
void split(int x, int y) {
	mkroot(x), access(y), splay(y);
}
void link(int x, int y) {
	mkroot(x);
	if(find(y)!=x) fa[x] = y;
}
void cut(int x, int y) {
	mkroot(x);
	if(find(y) == x && fa[y] == x && !son[y][0])
		fa[y] = son[x][1] = 0, update(x);
}
\end{minted}

\section{图论}

\subsection{差分约束}

$ a[x] - a[y] \leq w$ $\implies$ $y$ 向 $x$ 连长度为 $w$ 的有向边。

\subsection{floyd}

\begin{minted}{cpp}
REP(k, 1, n) REP(x, 1, n) REP(y, 1, n) chmin(f[x][y], f[x][k] + f[k][y]);
\end{minted}

\subsection{dinic}

\begin{minted}{cpp}
const i64 INF = 2e16L;
struct Dinic {
struct Node { int to; i64 cap, flow; };
int n; vector<Node> e;
vector<int> cur, dis;
vector<vector<int>> adj;
Dinic(int siz) { n = siz; adj.assign(n+1, {}); }
void add(int u, int v, i64 w) {
	adj[u].push_back(e.size()); e.push_back({v, w, 0});
	adj[v].push_back(e.size()); e.push_back({u, 0, 0});
}
int bfs(int s, int t) {
	dis.assign(n+1, {}); cur.assign(n+1, {});
	queue<int> Q;
	for (Q.push(s), dis[s] = 1; Q.size(); ) {
		int u = Q.front(); Q.pop();
		for (auto i : adj[u]) {
			if (!dis[e[i].to] && e[i].cap-e[i].flow)
				dis[e[i].to] = dis[u] + 1, Q.push(e[i].to);
		}
	}
	return dis[t];
}
i64 dfs(int u, i64 flow, int t) {
	if (u == t || !flow) return flow;
	i64 sum = 0, res;
	for (int &id = cur[u]; id < ssize(adj[u]); id ++) {
		int i = adj[u][id];
		if (dis[e[i].to] == dis[u] + 1 && (res = dfs(e[i].to, min(flow, e[i].cap - e[i].flow), t))) {
			e[i].flow += res, e[i^1].flow -= res;
			sum += res, flow -= res;
			if (!flow) break;
		}
	}
	return sum;
}
i64 solve(int s, int t) {
	i64 ans = 0;
	for (; bfs(s, t); ) ans += dfs(s, INF, t);
	return ans;
}
};
\end{minted}

对于上下界最大流问题：

\begin{itemize}
\item 对于 $u \to u$，范围为 $[l, r]$ 的边：建边 $u \xrightarrow{r - l} v$，$tot[u]$ 减 $l$，$tot[v]$ 加 $l$。
\item 对于所有 $tot[i] > 0$ 的点 $i$：建边 $s' \xrightarrow{tot[i]} i$ 且让 $sum$ 加上 $tot[i]$；
\item 对于所有 $tot[i] < 0$ 的点 $i$：建边 $i \xrightarrow{-tot[i]} t'$。（注意这里 $i$ 都包括 $s$ 和 $t$）
\item 建边 $t \xrightarrow{\inf} s$，然后跑 $s'$ 到 $t'$ 的最大流 $flow_1$，$flow_1 \neq sum$，则无解。
\item 删除 $t \xrightarrow{\inf} s$ 的边，跑 $s$ 到 $t$ 的最大流 $flow_2$，$flow_1 + flow_2$ 就是答案。
\end{itemize}

\subsection{费用流 (EK)}

\begin{minted}{cpp}
const i64 INF = 1e16L;
using pr = pair<i64, int>;
struct Node { int to; i64 vol, flow, cost; };
vector<vector<int>> adj; vector<int> from, vis;
vector<Node> e; vector<i64> d, dis; i64 n, F, C;
void init(int siz) {
	n = siz; adj.assign(n+1, {}); e = {{}, {}};
	from.assign(n+1, 0); vis.assign(n+1, 0);
	d.assign(n+1, 0); dis.assign(n+1, 0);
}
void add(int x, int y, i64 f, i64 c) {
	adj[x].push_back(e.size()); e.push_back({y, f, 0, c});
	adj[y].push_back(e.size()); e.push_back({x, 0, 0, -c});
}
int spfa(int s, int t) {
	queue<int> Q; d.assign(n+1, INF);
	for (d[s] = 0, vis[s] = 1, Q.push(s); Q.size(); ) {
		auto x = Q.front(); Q.pop(); vis[x] = 0;
		for (auto i : adj[x])
			if (e[i].vol - e[i].flow && d[e[i].to] > d[x] + e[i].cost) {
				d[e[i].to] = d[x] + e[i].cost; from[e[i].to] = i;
				if (!vis[e[i].to]) vis[e[i].to] = 1, Q.push(e[i].to);
			}
	}
	return d[t] < INF;
} 
int dij(int s, int t) {
	priority_queue<pr, vector<pr>, greater<pr>> Q;
	dis.swap(d); d.assign(n+1, INF);
	vis.assign(n+1, 0); from.assign(n+1, 0);
	for (Q.emplace(d[s] = 0, s); Q.size(); ) {
		auto x = Q.top().second; Q.pop();
		if (vis[x]) continue; vis[x] = 1;
		for (auto i : adj[x]) {
			const i64 v = e[i].cost + dis[x] - dis[e[i].to];
			if (e[i].vol - e[i].flow && d[e[i].to] > d[x] + v)
				from[e[i].to] = i, Q.emplace(d[e[i].to] = d[x]+v, e[i].to);
		}
	}
	for (int i = 0; i <= n; i ++) d[i] += dis[i]; return d[t] < INF;
}
array<i64, 2> EK(int s, int t) {
	spfa(s, t); i64 F = 0, C = 0, fl;
	for (; fl = INF, dij(s, t); ) {
		for (int i = from[t]; i; i = from[e[i^1].to])
			fl = min<i64> (e[i].vol - e[i].flow, fl);
		for (int i = from[t]; i; i = from[e[i^1].to])
			e[i].flow += fl, e[i^1].flow -= fl;
		F += fl, C += fl * d[t];
	}
	return {F, C};
}
\end{minted}

对于有负边的费用流问题，先按照上下界的方式让负边满流。

注意费用来源于三个部分（负边满流、$s'$ 到 $t'$ 可行流的费用、$s$ 到 $t$ 的费用）

\subsection{tarjan(强联通分量)}

\begin{minted}{cpp}
int dfn[N], low[N], bel[N], st[N], top, cnt, tms;
vector<int> adj[N], scc[N];
void tarjan(int u) {
	dfn[u] = low[u] = ++tms, st[++top] = u;
	for (auto v : adj[u]) {
		if (!dfn[v]) tarjan(v), chmin(low[u], low[v]);
		else if (!bel[v]) chmin(low[u], dfn[v]);
	}
	if (low[u] == dfn[u]) {
		int z; cnt ++;
		do z = st[top--], bel[z] = cnt, scc[cnt].push_back(z);
		while (z != u);
	}
}
\end{minted}

\subsection{tarjan(边双)}

\begin{minted}{cpp}
vector<int> bcc[N];
int dfn[N], low[N], st[N], bel[N], top, cnt, tms;
void tarjan(int u, int in) {
	low[u] = dfn[u] = ++tms, st[++top] = u;
	for (auto [v, id] : adj[u]) {
		if (id == in) continue;
		if (!dfn[v]) tarjan(v, id); chmin(low[u], low[v]);
		else chmin(low[u], dfn[v]);
	}
	if (dfn[u] == low[u]) {
		int z; cnt ++;
		do z = st[top--], bcc[cnt].push_back(z), bel[z] = cnt;
		while (z != u);
	}
}
\end{minted}

\subsection{tarjan(点双)}

\begin{minted}{cpp}
int dfn[N], low[N], st[N], cut[N], top, tms, cnt;
vector<int> adj[N], bcc[N];
void tarjan(int u, int fa) {
	dfn[u] = low[u] = ++tms, st[++top] = u; int ch = 0;
	for (auto v : adj[u]) {
		if (!dfn[v]) {
			tarjan(v, u), chmin(low[u], low[v]);
			if (low[v] >= dfn[u]) {
				if (++ch > 1 && fa) cut[u] = 1;
				int z; cnt ++;
				do z = st[top--], bcc[cnt].push_back(z);
				while (z != v);
				bcc[cnt].push_back(u);
			}
		}
		else chmin(low[u], dfn[v]);
	}
	if (!fa && !ch) bcc[++cnt] = {u}; // 特判独立点
}
\end{minted}

\section{Misc}

\subsection{cout精度}

\begin{minted}{cpp}
cout.setf(ios::fixed); cout.precision(15);
\end{minted}

%\subsection{int128 输入输出}
%
%\begin{minted}{cpp}
%istream& operator>>(istream& cin, i128& x) {
%	i128 w = 1, v = 0;
%	string s; cin >> s;
%	for (auto i : s) {
%		if (i == '-') w = -1;
%		else v = v * 10 + (i - '0');
%	}
%    return x = w * v, cin;
%}
%ostream& operator<<(ostream& cout, i128 x) {
%	if (x == 0) return cout << 0;
%	if (x < 0) cout << '-', x = -x;
%	string s;
%	while (x) s += '0' + x % 10, x /= 10;
%	reverse(s.begin(), s.end());
%	return cout << s;
%}
%\end{minted}

\subsection{上取整下取整}

\begin{minted}{cpp}
i64 ceilDiv(i64 n, i64 m) { // m > 0
	return n >= 0 ? (n + m - 1) / m : n / m;
}
i64 floorDiv(i64 n, i64 m) { // m > 0
	return n >= 0 ? n / m : (n - m + 1) / m;
}
\end{minted}

\subsection{mmap映射stdin}

\begin{minted}{cpp}
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int fd = 0; // 0 为 stdin  // int fd = open("*.in", O_RDONLY);
struct stat state; fstat(fd, &state); int len = state.st_size;
char* addr = (char*) mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
\end{minted}

\subsection{read()}

\begin{minted}{cpp}
int read() { // 换成 getchar_unlocked 可加快速度
	int x = 0, w = 1, ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') w = -1;
	for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';
	return x * w;
}
\end{minted}

\subsection{随机相关}

\begin{minted}{cpp}
mt19937 rnd(chrono::system_clock::now().time_since_epoch().count());
\end{minted}

\subsection{\_\_builtin\_xxx}

\texttt{\_\_builtin\_popcount{\color{red}{ll}}(x)}：\texttt{u32{\color{red}{/u64}}} 中 $1$ 的个数。

\texttt{\_\_builtin\_clz{\color{red}{ll}}(x)}：\texttt{u32{\color{red}{/u64}}} 最高位开始连续 $0$ 的个数。

\texttt{\_\_builtin\_ctz{\color{red}{ll}}(x)}：\texttt{u32{\color{red}{/u64}}} 最低位开始连续 $0$ 的个数。

\texttt{\_\_builtin\_parity{\color{red}{ll}}(x)}：\texttt{\_\_builtin\_popcount{\color{red}{ll}}(x) \& 1}

\texttt{\_\_builtin\_bswap16(x)}：对 \texttt{u16} 进行字节反转。

\texttt{\_\_builtin\_bswap32(x)}：对 \texttt{u32} 进行字节反转。

\texttt{\_\_builtin\_bswap64(x)}：对 \texttt{u64} 进行字节反转。

\begin{minted}{cpp}
u64 y = __builtin_bswap64(0xaabbccddeeff1122ULL); // y的值为0x2211ffeeddccbbaa
\end{minted}

\subsection{遍历 n 选 m 的方案}

\begin{minted}{cpp}
struct Comb { // for (auto i : Comb(n, m))
	int n, m; // 1 <= n && n <= 64 && 1 <= m && m <= n
	struct iterator {
		u64 x;
		u64 operator*() { return x; }
		bool operator==(const iterator& oth) const { return x == oth.x; }
		auto& operator++() {
			u64 b = x & -x, t = x + b, c = t & -t, m = (c / b >> 1) - 1;
			return x = t | m, *this;
		}
	};
	iterator begin() const { return iterator{(1ULL << m) - 1}; }
	iterator end() const { return ++(iterator{((1ULL << m) - 1) << (n - m)}); }
};
\end{minted}

\subsection{<ext/pbds/>}

\begin{itemize}
\item 哈希表
\begin{minted}{cpp}
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
__gnu_pbds::gp_hash_table<int, int> mp1; // 拉链法
__gnu_pbds::cc_hash_table<int, int> mp2; // 探测法
\end{minted}
\item 平衡树
\begin{minted}{cpp}
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
template<class T, class TT = __gnu_pbds::null_type>
using ordered_set = __gnu_pbds::tree<
	T, TT, std::less<T>,
	__gnu_pbds::rb_tree_tag,
	// rb_tree_tag 红黑树
	// splay_tree_tag splay树
	__gnu_pbds::tree_order_statistics_node_update
>;
\end{minted}
\texttt{order\_of\_key(x)}  返回比 $x$ 小的数的数量。

\texttt{find\_by\_order(x)}  返回排名 $x$ 所对应元素的迭代器。

\begin{minted}{cpp}
ordered_set<int> s;
s.insert(...); // 1, 3, 5, 7, 11
REP(i, 0, 6) cout << *s.find_by_order(i) << " "; cout << "\n";
// 1, 3, 5, 7, 11, 0, 0
REP(i, 0, 12) cout << s.order_of_key(i) << " "; cout << "\n";
// 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5
//   (1)   (3)   (5)   (7)         (11)
\end{minted}

\texttt{split(x,b)} 按照 $x$ 分裂，小于等于 $x$ 的属于当前树，其余的属于 $b$ 树。

\texttt{join(x)} 将两颗树合并。前提是两者值域没有交集。
\item 可并堆
\begin{minted}{cpp}
__gnu_pbds::priority_queue<int, less<int>, // 小根堆用 greater
	__gnu_pbds::pairing_heap_tag> q;
//     pairing_heap_tag     配对堆
//     binomial_heap_tag    二项堆
//     rc_binomial_heap_tag 冗余计数二项堆
//     binary_heap_tag      二叉堆
//     thin_heap_tag        斐波那契堆
\end{minted}

\texttt{a.join(b)}: 把优先队列 $b$ 合并进 $a$ 并把 $b$ 清空

\item rope

\begin{minted}{cpp}
#include <ext/rope>
__gnu_cxx::rope<char> rp = "1234";
rp.append("abcd");       // 1234abcd
rp.append('$');          // 1234abcd$
rp.replace(3, 2, "***"); // 123***bcd$
rp.append(4, ';');       // 123***bcd$;;;;
rp.erase(2, 3);          // 12*bcd$;;;;
rp.insert(6, 3, '!');    // 12*bcd!!!$;;;;
\end{minted}
\end{itemize}

\subsection{时间相关}

真遇到这种大模拟，建议参考下列源代码（低版本可能直接叫 \texttt{datetime.py}）

\texttt{/usr/lib/python3.13/\_pydatetime.py}

\subsection{火车头精简版}

\begin{minted}{cpp}
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,sse4a,abm,avx,avx2,avx512f,prefer-vector-width=512,tune=native")
#pragma GCC optimize("inline")
\end{minted}

%\subsection{导数积分}
%
%\textbf{
%\small\bfseries
%\begin{align*}
%\left(\frac{u}{v}\right)' &= \frac{u'v-uv'}{v^2}  &  (\arctan (x))' &= \frac{1}{1+x^2}                    & (\mathrm{arcsinh} (x))' &= \frac{1}{\sqrt{1+x^2}}               \\
%(a^x)' &= (\ln a)a^x                              &  (\mathrm{arccot} (x))' &= -\frac{1}{1+x^2}           & (\mathrm{arccosh} (x))' &= \frac{1}{\sqrt{x^2-1}}               \\
%(\tan (x))' &= \sec^2 (x)                         &  (\mathrm{arcsec} (x))' &= \frac{1}{|x|\sqrt{x^2-1}}  & (\mathrm{arctanh} (x))' &= \frac{1}{1-x^2}                      \\
%(\cot (x))' &= -\csc^2 (x)                        &  (\mathrm{arccsc} (x))' &= -\frac{1}{|x|\sqrt{x^2-1}} & (\mathrm{arccoth} (x))' &= \frac{1}{1-x^2}                      \\
%(\sec (x))' &= \tan (x) \sec (x)                  &  (\tanh (x))' &= \mathrm{sech}^2 (x)                  & (\mathrm{arcsech} (x))' &= -\frac{1}{x\sqrt{1-x^2}}             \\
%(\csc (x))' &= -\cot (x) \csc (x)                 &  (\coth (x))' &= -\mathrm{csch}^2 (x)                 & (\mathrm{arccsch} (x))' &= -\frac{1}{|x|\sqrt{1+x^2}}           \\
%(\arcsin (x))' &= \frac{1}{\sqrt{1-x^2}}          &  (\mathrm{sech} (x))' &= -\mathrm{sech} (x) \tanh (x) &                         &                                       \\
%(\arccos (x))' &= -\frac{1}{\sqrt{1-x^2}}         &  (\mathrm{csch} (x))' &= -\mathrm{csch} (x) \coth (x) &                         &                                       \\
%\end{align*}
%}
%
%{
%\Large
%$ax^2 + bx + c(a > 0)$
%
%\Large
%$$ \int\frac{dx}{ax^2+bx+c} = \begin{cases}
%	\frac{2}{\sqrt{4ac-b^2}}\arctan\frac{2ax+b}{\sqrt{4ac-b^2}}+C & (b^2 < 4ac) \\
%	\frac{1}{\sqrt{b^2-4ac}}\ln\left|\frac{2ax+b-\sqrt{b^2-4ac}}{2ax+b+\sqrt{b^2-4ac}}\right|+C & (b^2 > 4ac)
%\end{cases} $$
%
%$$ \int\frac{x}{ax^2+bx+c}dx = \frac{1}{2a}\ln|ax^2+bx+c|-\frac{b}{2a}\int\frac{dx}{ax^2+bx+c} $$
%
%}
%
\subsection{STL 积分/求和}

$$
\int_0^1 t^{x-1}(1-t)^{y-1}\,dt = \mathrm{beta}(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
$$

$$
\int_0^{+\infty} t^{num-1}e^{-t}\,dt = \mathrm{tgamma}(num) = e^{\mathrm{lgamma}(num)}
$$

$$
\int_0^{phi} \frac{d\theta}{\sqrt{1-k^2\sin^2\theta}} = \mathrm{ellint\_1}(k,phi)
$$

$$
\int_0^{phi} \sqrt{1-k^2\sin^2\theta}\,d\theta = \mathrm{ellint\_2}(k,phi)
$$

$$
\int_{num}^{+\infty} \frac{e^{-t}}{t}\,dt = -\mathrm{expint}(-num)
$$

$$
\sum_{n=1}^{+\infty} n^{-num} = \mathrm{riemann\_zeta}(num)
$$

$$
\frac{2}{\sqrt{\pi}}\int_0^{arg} e^{-t^2}\,dt = \mathrm{erf}(arg)
$$

%$$
%J_{\alpha} (x) = \sum_{m = 0}^{\infty} \frac{(-1)^m}{m ! \Gamma (m + \alpha + 1)} \left(\frac{x}{2}\right) ^ {(2 m + \alpha)} = \mathrm{jn} (\alpha, x)
%$$
%
%$$
%Y_{\alpha} (x) = \frac{J_{\alpha} (x) \cos (\alpha \pi) - J_{ - \alpha} (x)}{\sin (\alpha \pi)} = \mathrm{yn} (\alpha, x)
%$$

\subsection{其他公式}

%$$ d(i \cdot j) = \sum_{x | i} \sum_{y | j} [\gcd (x, y) = 1] = \sum_{p \mid \gcd (i, j)} \mu (p) \cdot d (\frac{i}{p}) \cdot d (\frac{j}{p}) $$

$$
d(i \cdot j) = \sum_{p \mid i, p \mid j} \mu (p) \cdot d (\frac{i}{p}) \cdot d (\frac{j}{p})
\qquad
\epsilon (x) = \sum \limits_{d \mid x} \mu (d)
$$

$$
\mathrm{I} * \mathrm{I} = \mathrm{d}
\quad
\mathrm{\varphi} * \mathrm{I} = \mathrm{Id}
\quad
\Lambda * \mathrm{I} = \log
\quad
\mathrm{Id}_k * \mathrm{I} = \mathrm{\sigma}_k
\quad
\mathrm{\mu} * \mathrm{I} = \mathrm{\epsilon}
$$

$$
f * g = h \implies g(1) * S(n) = \sum_{i = 1}^{n} h(i) - \sum_{i = 2}^{n} g(i) S(\left \lfloor \frac{n}{i} \right \rfloor)
$$

$$
f = g * h \implies h(p ^ c) = f(p ^ c) - \sum_{i = 1}^{c} g(p ^ i) \cdot h(p ^ {c-i})
$$

\subsection{bashrc}

\begin{minted}{sh}
mk() { local F="$1" ; shift ; g++ "$F.cpp" -o "$F" "$@"; }
hash() {
cpp -fpreprocessed -P "$1" | python3 -c '
import hashlib, re, sys
for i in sys.stdin.readlines():
    print(hashlib.md5(re.sub(r"\s", "", i).encode()).hexdigest()[:4], i[:-1])
'
}
ulimit -s 1048576
ulimit -v 1048576
\end{minted}

\subsection{编译参数}

\begin{itemize}
\item \texttt{-fsanitize=address,undefined,leak -ftrapv}：检测内存错误、UB、内存泄漏、有符号溢出检查。
\item \texttt{-Wall -Wextra -Wshadow -Wconversion -Wsign-conversion}：常见警告，变量 shadow、隐式类型转换、有符号/无符号转换。
\item \texttt{-D\_GLIBCXX\_DEBUG}：STL debug。
\end{itemize}

\subsection{Xor \space Shift}

\begin{minted}{cpp}
u64 xorshift(u64 x) { return x^=x<<13, x^=x>>7, x^=x<<17, x; }
u32 xorshift(u32 x) { return x^=x<<13, x^=x>>17, x^=x<<5, x; }
\end{minted}

\subsection{python Decimal}

\begin{minted}{py}
from decimal import Decimal, getcontext, localcontext
getcontext().prec = 1000 # 全局环境 精度为 1000
with localcontext() as ctx:
	ctx.prec = 1000 # 临时环境
a = Decimal("1.14514") # a.sqrt(), a.ln(), a.exp(), ...
\end{minted}

\subsection{python Fractions}

\begin{minted}{py}
from fractions import Fraction
a = Fraction(3, 4)    # 3/4
print(f.numerator, f.denominator) # 3 4
# 找到最接近的分数，分母不超过指定值
Fraction('3.1415926535897932').limit_denominator(10)  # 22/7
Fraction('3.1415926535897932').limit_denominator(100)  # 311/99
\end{minted}

\subsection{浮点数 cmp (对拍用)}

\begin{minted}{py}
import sys # 用法: python ./cmp.py ./a.out ./a.ans
get = lambda name : [float(i) for i in open(name, 'r').read().split()]
if __name__ == "__main__":
	a, b = get(sys.argv[1]), get(sys.argv[2])
	assert len(a) == len(b)
	for x, y, i in zip(a, b, range(len(a))):
		assert abs(x - y) / max(1, abs(y)) <= 1E-4, f"Wrong at {i+1}-th"
\end{minted}

%\subsection{质数表}
%
%\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
%\hline
%2 & 3 & 5 & 7 & 11 & 13 & 17 & 19 & 23 & 29\\
%\hline
%31 & 37 & 41 & 43 & 47 & 53 & 59 & 61 & 67 & 71\\
%\hline
%73 & 79 & 83 & 89 & 97 & 101 & 103 & 107 & 109 & 113\\
%\hline
%127 & 131 & 137 & 139 & 149 & 151 & 157 & 163 & 167 & 173\\
%\hline
%179 & 181 & 191 & 193 & 197 & 199 & 211 & 223 & 227 & 229\\
%\hline
%233 & 239 & 241 & 251 & 257 & 263 & 269 & 271 & 277 & 281\\
%\hline
%283 & 293 & 307 & 311 & 313 & 317 & 331 & 337 & 347 & 349\\
%\hline
%353 & 359 & 367 & 373 & 379 & 383 & 389 & 397 & 401 & 409\\
%\hline
%419 & 421 & 431 & 433 & 439 & 443 & 449 & 457 & 461 & 463\\
%\hline
%467 & 479 & 487 & 491 & 499 & 503 & 509 & 521 & 523 & 541\\
%\hline
%547 & 557 & 563 & 569 & 571 & 577 & 587 & 593 & 599 & 601\\
%\hline
%607 & 613 & 617 & 619 & 631 & 641 & 643 & 647 & 653 & 659\\
%\hline
%661 & 673 & 677 & 683 & 691 & 701 & 709 & 719 & 727 & 733\\
%\hline
%739 & 743 & 751 & 757 & 761 & 769 & 773 & 787 & 797 & 809\\
%\hline
%811 & 821 & 823 & 827 & 829 & 839 & 853 & 857 & 859 & 863\\
%\hline
%877 & 881 & 883 & 887 & 907 & 911 & 919 & 929 & 937 & 941\\
%\hline
%947 & 953 & 967 & 971 & 977 & 983 & 991 & 997 & 1009 & 1013\\
%\hline
%\end{tabular}


%\subsection{}
%
%\begin{minted}{cpp}
%
%\end{minted}


\end{document}
