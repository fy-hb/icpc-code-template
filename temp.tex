\documentclass[a4paper,landscape,twocolumn]{ctexart}
\usepackage[Glenn]{fncychap}
\usepackage[procnames]{listings}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{lastpage}
\usepackage[UTF8]{ctex}
%\usepackage{minted}
\usepackage{relsize}
%\usepackage{CJKutf8}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage {epigraph}
\usepackage {expdlist}
\usepackage {graphicx}

%\setmainfont{LXGW WenKai}
\setmainfont{Source Han Serif CN SemiBold}
%\setmathrm{Source Han Serif CN SemiBold}
%\setmathsf{Source Han Serif CN SemiBold}
%\setmathtt{Source Han Serif CN SemiBold}
\setsansfont{WenQuanYi Micro Hei}
\setmonofont{JetBrains Mono NL}
\setCJKmainfont{Source Han Serif CN}
%\setCJKmainfont{LXGW WenKai}
%\setCJKmainfont{WenQuanYi Micro Hei}

\geometry{left=1cm,right=1cm,top=1.5cm,bottom=1.5cm}
%\setCJKmainfont{SimSun}

% 调整列间距（可选）
\setlength{\columnsep}{0.4cm}
%\setlength\columnseprule{0.4pt}
%\setCJKmainfont{SimSun}

\def\KWauthor{frost\_ice @ HEU}
\def\KWtitle{Code Template}

\title{\textlarger[10]{\KWtitle}}
\author{\KWauthor}
%\date{2024年12月}

% 定义目录格式
\makeatletter
\renewcommand\tableofcontents{%
	\section*{\makebox[\linewidth][c]{\contentsname}%
		\@mkboth{\MakeUppercase\contentsname}{\MakeUppercase\contentsname}}%
	\begin{multicols}{2}%
		\@starttoc{toc}%
	\end{multicols}
}
\makeatother

% 代码高亮的基本颜色设置
\definecolor{mygreen}{RGB}{28,172,0}
\definecolor{mylilas}{RGB}{170,55,241}
\definecolor{mygray}{RGB}{128,128,128}
\definecolor{mymauve}{RGB}{124,6,123}
\definecolor{myblue}{RGB}{14,84,175}
\definecolor{mybg}{RGB}{248,248,248}

% 代码样式设置
\lstset{
	language=C++,                           % 设置语言
	basicstyle=\small\ttfamily,                   % 基本代码风格
	columns=fixed,                          % 
	numbers=left,                           % 行号的位置在左边
	numberstyle=\small\color{mygray},       % 行号的样式
	stepnumber=1,                           % 行号的步进值
	numbersep=5pt,                          % 行号的距离
%	backgroundcolor=\color{mybg},           % 代码块背景色
	showspaces=false,                       % 不显示空格
	showstringspaces=false,                 % 不显示字符串中的空格
	showtabs=false,                         % 不显示制表符
	frame=single,                           % 显示框架
	rulecolor=\color{black},                % 框架颜色
	tabsize=2,                              % 制表符长度
	captionpos=t,                           % 标题位置 t=top
	breaklines=true,                        % 自动换行
%	breakatwhitespace=true,                 % 只在空格处换行
	postbreak=\raisebox{0ex}[0ex][0ex]      % 换行的样式
		{\ensuremath{\hookrightarrow}\space},
	commentstyle=\color{mygreen}\CJKfontspec{WenQuanYi Micro Hei Mono},
								            % 注释的样式
	keywordstyle={\bfseries\color{blue}},   % 关键字的样式
	stringstyle=\color{mymauve},            % 字符串样式
	escapeinside={(*@}{@*)},                % 特殊符号
	morekeywords={constexpr,REP,REV,*,...},                   % 更多的关键字
	deletekeywords={...},                   % 删除默认的关键字
	% 完整的边框
	xleftmargin=2em,                        % 左边距
%	xrightmargin=2em,                       % 右边距
%	aboveskip=1em,                          % 上边距
%	belowskip=1em,                          % 下边距
	% 增强的关键字
	emph={int,char,double,float,unsigned,void,bool,i64,u64,i32,u32,db,cp,long},
	emphstyle={\bfseries\color{mymauve}},
	% 标识符样式
	identifierstyle=\color{black},
}

\newcommand{\point}[1]{
	\begin{itemize}
		\item \textbf{#1}
	\end{itemize}
}

\begin{document}

\newgeometry{left=1cm,right=1cm,top=1.5cm,bottom=1.5cm}
\begin{titlepage}
\thispagestyle{plain}
\thispagestyle{empty}
\begin{center}
	~\\[100pt]
	\hrule\ \\[8pt]
	\fontsize{48pt}{\baselineskip}\selectfont  \textsc{\KWtitle}\\[8pt]
	~\\[20pt]
%		\includegraphics[scale=1]{./cover.jpg}    
	~\\[50pt]
	\huge \KWauthor\\[8pt]
	\Large Last build at \today
	~\\[100pt]
	\hrule\ \\[8pt]
\end{center}
\pagebreak
%\pagestyle{plain}
\pagestyle{fancy}
\lhead{}
\rhead{}
\chead{\KWtitle, \KWauthor}
\cfoot{}
\tableofcontents
\end{titlepage}
\restoregeometry

\pagestyle{fancy}

\pagestyle{fancy}
\lhead{\large\KWtitle, \KWauthor}
\chead{}
\rhead{\Huge\bfseries\thepage}
\lfoot{}
\cfoot{第 \thepage 页 - 共 \pageref{LastPage} 页}
\rfoot{}


\section{数论}

\subsection{ExGcd}

\begin{lstlisting}[]
// result : -b < x < b AND -a < y <= a when a,b != 0
i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {
	if (b == 0) { x = 1, y = 0; return a; }
	i64 d = exgcd(b, a % b, y, x);
	y -= a / b * x; return d;
}
\end{lstlisting}

\begin{lstlisting}[]
array<int, 3> exgcd(int a, int b) {
	if (!b) return {a, 1, 0};
	auto [d, x, y] = exgcd(b, a % b);
	return {d, y, x - y * (a / b)};
}
\end{lstlisting}

\subsection{euler\_phi}

\begin{lstlisting}[]
int euler_phi(int n) {
	int ans = n;
	for (int i = 2; i * i <= n; i++)
		if (n % i == 0) {
			ans = ans / i * (i - 1);
			while (n % i == 0) n /= i;
		}
	if (n > 1) ans = ans / n * (n - 1);
	return ans;
}
\end{lstlisting}

\subsection{预处理逆元}

\begin{lstlisting}[]
void Init(int siz) {
	inv[1] = 1;
	REP(i, 2, siz)
		inv[i] = (mod - mod/i) * inv[mod%i] % mod;
}
\end{lstlisting}

\subsection{线性筛}

\begin{lstlisting}[]
const int N = 1e5+10;
bitset<N> vis;
vector<int> primes;
// Mobius函数, 欧拉函数
int mu[N], phi[N];
// 约数个数, 最小质因子数量
int d[N], num[N];
// 约数和, 最小质因子的p^0+p^1+...+p^k
int f[N], g[N];
static inline void Init(int n) {
	vis[1] = 1;
	// mu[1] = 1;
	// phi[1] = 1;
	// d[1] = 1, num[1] = 0;
	// g[1] = f[1] = 1;
	for (int i = 2; i <= n; i ++) {
		if (!vis[i]) {
			primes.push_back(i);
			// mu[i] = -1;
			// phi[i] = i-1;
			// num[i] = 1, d[i] = 2;
			// g[1] = f[1] = i+1;
		}
		for (auto j : primes) {
			if (i*j > n) break;
			vis[i*j] = 1;
			// mu[i*j] = -mu[i];
			// phi[i*j] = phi[i]*phi[j];
			// num[i*j] = 1, d[i*j] = d[i]<<1;
			// g[i*j] = j+1, f[i*j] = f[i]*f[j];
			if (i%j == 0) {
				// mu[i*j] = 0;
				// phi[i*j] = phi[i]*j;
				// num[i*j] = num[i]+1, d[i*j] = d[i] / (num[i]+1) * (num[i]+2);
				// g[i*j] = g[i]*j+1, f[i*j] = f[i] / g[i] * g[i*j];
				break;
			}
		}
	}
}
\end{lstlisting}

\subsection{Miller–Rabin}

\begin{lstlisting}[]
int millerRabin(i64 n) {
	if (n < 3 || n % 2 == 0) return n == 2;
	i64 u = n - 1, t = 0;
	while (u % 2 == 0) u /= 2, ++t;
	for (i64 i = 0; i < test_time; ++i) {
		i64 a = rand() % (n-2) + 2, v = qpow(a, u, n);
		if (v == 1) continue;
		for (i64 s = 0; s < t; ++s) {
			if (v == n-1) break;
			if (s == t-1) return 0;
			v = i64(v) * v % n;
		}
	}
	return 1;
}
\end{lstlisting}

\subsection{Mint}

\begin{lstlisting}[]
constexpr int mod = 998'244'353;
constexpr int qpow(int x, int y) {
	int ans = 1;
	while (y) {
		if (y&1) ans = 1ll * ans * x % mod;
		x = 1ll * x * x % mod; y >>= 1;
	}
	return ans;
}
struct Mint {
	int val;
	static constexpr int Normal(int x) { return x<0&&(x+=mod)||x>=mod&&(x-=mod), x; }
	constexpr Mint() : val(0) {}
	constexpr Mint(i64 x): val(Normal(x % mod)) {}
	constexpr i64 Inv() const { return qpow(val, mod-2); }
	constexpr i64 Pow(i64 p) const { return qpow(val, p); }
};
#define CE constexpr
CE Mint operator- (Mint a) { return mod-a.val; }
CE bool operator== (Mint a, Mint b) { return a.val == b.val; }
CE Mint operator+ (Mint a, Mint b) { return a.val + b.val; }
CE Mint operator- (Mint a, Mint b) { return a.val - b.val; }
CE Mint operator* (Mint a, Mint b) { return 1ll * a.val * b.val; }
CE Mint operator/ (Mint a, Mint b) { return 1ll * a.val * b.Inv(); }
CE Mint& operator+= (Mint &a, Mint b) { return a = a + b; }
CE Mint& operator-= (Mint &a, Mint b) { return a = a - b; }
CE Mint& operator*= (Mint &a, Mint b) { return a = a * b; }
CE Mint& operator/= (Mint &a, Mint b) { return a = a / b; }
CE Mint& operator++ (Mint &a) { return a += 1; }
CE Mint& operator-- (Mint &a) { return a -= 1; }
CE Mint operator++ (Mint &a, int) { auto b = a; return a += 1, b; }
CE Mint operator-- (Mint &a, int) { auto b = a; return a -= 1, b; }
template <typename S> S& operator<< (S &s, Mint a) { return s << a.val; }
CE Mint operator "" _M (unsigned long long x) { return x; }
\end{lstlisting}

\section{数学}

\subsection{遍历所有素勾股数}

\begin{lstlisting}
void gen(int a, int b, int c) { // a < b
    gen( a + 2*b + 2*c,  2*a + b + 2*c,  2*a + 2*b + 3*c);
    gen(-a + 2*b + 2*c, -2*a + b + 2*c, -2*a + 2*b + 3*c);
    gen( a - 2*b + 2*c,  2*a - b + 2*c,  2*a - 2*b + 3*c);
} // 用法: gen(3, 4, 5);
\end{lstlisting}

\subsection{组合数}

\begin{lstlisting}
i64 fac[N], inv[N];
static inline void Init(i64 n) {
	fac[0] = 1;
	REP(i, 1, n)
		fac[i] = fac[i-1] * i % mod;
	inv[n] = qpow(fac[n], mod - 2);
	REV(i, n, 1)
		inv[i-1] = inv[i] * i % mod;
}
static inline i64 C(i64 x, i64 y) {
	if (y > x || y < 0) return 0;
	return (fac[x]*inv[y]%mod)*inv[x-y] % mod;
}
\end{lstlisting}

\subsection{组合数学相关}

\begin{lstlisting}[]
// c[p]中 i个元素>=k的方案数.
inline i64 calc(i64 p, i64 m, i64 k, i64 i) {
	if (i * k > m || i > p) return 0;
	return (C(p, i) * C(m-i*k+p-1, p-1) % mod
	+ mod - calc(p, m, k, i+1)) % mod;
}
\end{lstlisting}

\subsection{小球装盒问题}

\renewcommand{\arraystretch}{1.5}
\begin{tabular}{|c|c|c|c|}
	\hline
	k 个球 & m 个盒子 & 允许有空 & 方案数 \\
	\hline
	\multirow{4}{*}[0em]{各不相同} & \multirow{2}{*}[0em]{各不相同} & 是 & \Large$m ^ k$ \\
	\cline{3-4}
	& & 否 & \Large$m ! \cdot St2 (k, m)$ \\
	\cline{2-4}
	& \multirow{2}{*}[0em]{完全相同} & 是 & \Large$\sum_{i=1}^{m} {St2 (k, i)}$ \\
	\cline{3-4}
	& & 否 & \Large$St2 (k, m)$ \\
	\hline
	\multirow{4}{*}[0em]{完全相同} & \multirow{2}{*}[0em]{各不相同} & 是 & \Large$C (m + k - 1, m-1)$ \\
	\cline{3-4}
	& & 否 & \Large$C (k-1, m-1)$ \\
	\cline{2-4}
	& \multirow{2}{*}[0em]{完全相同} & 是 & \Large$[x^k] \prod_{i=1}^{m} \frac{1}{1 - x ^ i}$ \\
	\cline{3-4}
	& & 否 & \Large$ [x^k] \prod_{i=1}^{m} \frac{x ^ m}{1 - x ^ i} $ \\
	\hline
\end{tabular}

\subsection{FFT}

\begin{lstlisting}
using db = long double;
// cp::real  cp::imag  std::conj  std::arg
using cp = complex<db>;
const db PI = acos(-1.L);
const int N = 4e6+10;
int rev[N], lim;
cp wn[N], a[N], b[N];
int ans[N];
void init(int siz) {
	lim = 4 << __lg(siz);
	for (static int i = 1; i < lim; i <<= 1)
		for (int j = 0; j < i; j ++)
			wn[i+j] = polar(1.L, db(j) / db(i) * PI);
	for (int i = 1; i < lim; i ++)
		rev[i] = rev[i>>1] >> 1 | (i%2u * lim / 2);
}
void dft(cp* a) {
	for (int i = 0; i < lim; i ++)
	if (rev[i] < i) swap(a[rev[i]], a[i]);
	for (int i = 1; i < lim; i <<= 1)
		for (int j = 0; j < lim; j += 2*i)
			for (int k = 0; k < i; k ++) {
				cp x = a[i+j+k] * wn[i+k];
				a[i+j+k] = a[k+j] - x;
				a[k+j] += x;
			}
}
void idft(cp* a) {
	dft(a); reverse(a+1, a+lim);
	for (int i = 0; i < lim; i ++)
	a[i] /= lim;
}
\end{lstlisting}

\subsection{FMT / 或卷积}

\begin{lstlisting}
void fmt(int* a) {
	// n = 1 << d
	REP(i, 0, d-1) REP(j, 0, n-1) if (j&(1<<i))
		// ifmt: a[j] -= a[j^(1<<i)];
		a[j] += a[j^(1<<i)];
}
\end{lstlisting}

\subsection{子集卷积}

\begin{lstlisting}
cin >> d; n = 1 << d;
REP(i, 0, n-1) cin >> a[__builtin_popcount(i)][i];
REP(i, 0, n-1) cin >> b[__builtin_popcount(i)][i];
REP(i, 0, d) fmt(a[i]), fmt(b[i]);
REP(i, 0, n-1) REP(j, 0, d) REP(k, 0, d-j)
c[j+k][i] += 1ll * a[j][i] * b[k][i];
REP(i, 0, d) ifmt(c[i]);
REP(i, 0, n-1)
cout << c[__builtin_popcount(i)][i] << " \n"[i==n-1];
\end{lstlisting}

\subsection{FWT}

\begin{lstlisting}
constexpr int inv2 = qpow(2, mod-2);
// constexpr array<int, 4> ...
CONV_OR  = {     1,      0,      1,        1};
INV_OR   = {     1,      0,  mod-1,        1};
CONV_AND = {     1,      1,      0,        1};
INV_AND  = {     1,  mod-1,      0,        1};
CONV_XOR = {     1,      1,      1,    mod-1};
INV_XOR  = {  inv2,   inv2,   inv2, mod-inv2};
void FWT(int* a, array<int, 4> ty) {
	for (int x = 2; x <= n; x <<= 1) {
		int k = x >> 1;
		for (int i = 0; i < n; i += x) {
			for (int j = 0; j < k; j++) {
				int tmp0 = (1ll * a[i + j] * ty[0] % mod
				+ 1ll * a[i + j + k] * ty[1] % mod) % mod;
				int tmp1 = (1ll * a[i + j] * ty[2] % mod
				+ 1ll * a[i + j + k] * ty[3] % mod) % mod;
				a[i + j] = tmp0, a[i + j + k] = tmp1;
			}
		}
	}
}
\end{lstlisting}

\section{二维计算几何}

\subsection{凸包}

\begin{lstlisting}
using pt = array<i64, 2>;
pt operator+ (pt a, pt b) { return {a[0] + b[0], a[1] + b[1]}; }
pt operator- (pt a, pt b) { return {a[0] - b[0], a[1] - b[1]}; }
i64 operator* (pt a, pt b) { return a[0] * b[0] + a[1] * b[1]; }
i64 operator^ (pt a, pt b) { return a[0] * b[1] - a[1] * b[0]; }
pt operator- (pt a) { return {-a[0], -a[1]}; }
db abs(pt a) { return __builtin_hypot(a[0], a[1]); }
i64 sq(pt a) { return a[0] * a[0]+ a[1] * a[1]; }
int check(pt x, pt y, pt z) { return ((y - x) ^ (y - z)) < 0; }
vector<int> work(const vector<pt> &p) {
	if (!p.size()) return {};
	int n = p.size(), top = -1;
	vector<int> ind(n), st(n+1), vis(n);
	REP(i, 0, n-1) ind[i] = i;
	ranges::sort(ind, [&] (int i, int j) { return p[i] < p[j]; });
	st[++top] = ind[0];
	REP(i, 0, n-1) {
		while (top >= 1 && !check(p[st[top-1]], p[st[top]], p[ind[i]]))
		vis[st[top]] = 0, top --;
		st[++top] = ind[i]; vis[ind[i]] = 1;
	}
	int siz = top;
	REV(i, n-2, 0) {
		if (vis[ind[i]]) continue;
		while (top > siz && !check(p[st[top-1]], p[st[top]], p[ind[i]]))
		vis[st[top]] = 0, top --;
		st[++top] = ind[i]; vis[ind[i]] = 1;
	}
	return st.resize(top), st;
}
\end{lstlisting}

\section{字符串}

\subsection{manacher}

\begin{lstlisting}
void manacher(int sz) {
	int R = 0, mid = 0;
	REP(i, 1, sz-1) {
		p[i] = R > i ? min(p[2*mid-i], R-i) : 1;
		while (s1[i+p[i]] == s1[i-p[i]]) p[i]++;
		if (i + p[i] > R)
		R = i + p[i], mid = i;
	}
}
int is_pal(int l, int r) {
	return p[l+r] > r - l;
}
/*
0 1 2 3 4 5 6 7 8 9 ...... [index]
  1   1   1   1   1   11  1   1   1   1   1
^ . a . b . c . b . a . a . b . c . b . a . @
    2   2   6   2   2   2   2   6   2   2
*/
\end{lstlisting}

\section{数据结构}

\subsection{[后缀加+前缀求和]树状数组}

\begin{lstlisting}
void Add(i64 p, i64 v) {
	for (int x = p; x <= n; x += x&-x)
		ta[x] += v, tb[x] += p * v;
}
i64 Query(i64 p, i64 ans = 0) {
	for (int x = p; x; x -= x&-x)
		ans += (p+1) * ta[x] - tb[x];
	return ans;
}
\end{lstlisting}

\subsection{二维树状数组}

\begin{lstlisting}
struct T {
	int tr[N][N];
	void Add(int p, int q, int v) {
		for (int x = p; x <= n; x += x&-x)
		for (int y = q; y <= n; y += y&-y)
		tr[x][y] += v;
	}
	int Query(int p, int q, int ans = 0) {
		for (int x = p; x >= 1; x -= x&-x)
		for (int y = q; y >= 1; y -= y&-y)
		ans += tr[x][y];
		return ans;
	}
} T, Tx, Txy, Ty;
void Add(int x, int y, int v) {
	T.Add(x, y, v);
	Tx.Add(x, y, v * x);
	Ty.Add(x, y, v * y);
	Txy.Add(x, y, v * x * y);
}
int Query(int x, int y) {
	return Txy.Query(x, y)
	- Tx.Query(x, y) * (y + 1)
	- Ty.Query(x, y) * (x + 1)
	+ T.Query(x, y) * (x*y + x + y + 1);
}
// (a, b) ~ (c, d)
void A(int a, int b, int c, int d, int v) {
	c ++, d ++;
	Add(c, d, v);
	Add(a, b, v);
	Add(a, d, -v);
	Add(c, b, -v);
}
int Q(int a, int b, int c, int d) {
	a --, b --;
	return Query(c, d)
	+ Query(a, b)
	- Query(a, d)
	- Query(c, b);
}
\end{lstlisting}

\subsection{树状数组select}

\begin{lstlisting}
// 最后一个 前缀和 <= k 的位置
int select(i64 k) {
	int x = 0; i64 cur = 0;
	for (int i = 1<<__lg(n); i; i /= 2) {
		if (x + i <= n && cur + tree[x+i] <= k) {
			x += i; cur = cur + tree[x];
		}
	}
	return x;
}
\end{lstlisting}

\subsection{单点修改线段树}

\begin{lstlisting}
struct Info { };
Info operator+ (const Info &a, const Info &b) {}
Info info[N<<2], init[N];
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
inline void PushUp(int x) {
	info[x] = info[ls(x)] + info[rs(x)];
}
void Build(int x, int l, int r) {
	if (l >= r) return info[x] = init[l], void ();
	int mid = (l+r) >> 1;
	Build(ls(x), l, mid);
	Build(rs(x), mid+1, r);
	PushUp(x);
}
void Modify(int x, int l, int r, int pos, const Info &val) {
	if (l == pos && pos == r) {
		return info[x] = val, void ();
	}
	if (pos < l || pos > r) return;
	int mid = (l+r) >> 1;
	if (pos <= mid) Modify(ls(x), l, mid, pos, val);
	if (pos > mid) Modify(rs(x), mid+1, r, pos, val);
	PushUp(x);
}
Info Query(int x, int l, int r, int L, int R) {
	if (L <= l && r <= R) return info[x];
	int mid = (l+r) >> 1;
	if (R <= mid) return Query(ls(x), l, mid, L, R);
	if (mid < L) return Query(rs(x), mid+1, r, L, R);
	return Query(ls(x), l, mid, L, R) + Query(rs(x), mid+1, r, L, R);
}
#undef ls
#undef rs
\end{lstlisting}

\subsection{区间修改懒标记线段树}

\begin{lstlisting}
struct Tag {
	void apply(const Tag &t) {}
	static Tag Id() {}
};
struct Info {
	void apply(const Tag &t) {}
};
Info operator+ (const Info &a, const Info &b) {}
Info info[N<<2], init[N]; Tag tag[N<<2];
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
inline void PushUp(int x) {
	info[x] = info[ls(x)] + info[rs(x)];
}
inline void Apply(int x, const Tag &val) {
	info[x].apply(val); tag[x].apply(val);
}
void PushDown(int x) {
	Apply(ls(x), tag[x]);
	Apply(rs(x), tag[x]);
	tag[x] = Tag::Id();
}
void Build(int x, int l, int r) {
	tag[x] = Tag::Id();
	if (l >= r) return info[x] = init[l], void ();
	int mid = (l+r) >> 1;
	Build(ls(x), l, mid);
	Build(rs(x), mid+1, r);
	PushUp(x);
}
void Modify(int x, int l, int r, int pos, const Info &val) {
	if (l == pos && pos == r) return info[x] = val, void ();
	int mid = (l+r) >> 1;
	PushDown(x);
	if (pos <= mid) Modify(ls(x), l, mid, pos, val);
	if (pos > mid) Modify(rs(x), mid+1, r, pos, val);
	PushUp(x);
}
void Add(int x, int l, int r, int L, int R, const Tag &val) {
	if (L <= l && r <= R) return Apply(x, val), void ();
	int mid = (l+r) >> 1;
	PushDown(x);
	if (mid >= L) Add(ls(x), l, mid, L, R, val);
	if (R > mid) Add(rs(x), mid+1, r, L, R, val);
	PushUp(x);
}
Info Query(int x, int l, int r, int L, int R) {
	if (L <= l && r <= R) return info[x];
	int mid = (l+r) >> 1;
	PushDown(x);
	if (R <= mid) return Query(ls(x), l, mid, L, R);
	if (mid < L) return Query(rs(x), mid+1, r, L, R);
	return Query(ls(x), l, mid, L, R) + Query(rs(x), mid+1, r, L, R);
}
#undef ls
#undef rs
\end{lstlisting}

\subsection{ST表}

\begin{lstlisting}
int f[N+50][20], n;
void Init() {
	REP(i, 1, __lg(n)) REP(j, 1, n+1-(1<<i))
		f[j][i]=gcd(f[j][i-1],f[j+(1<<(i-1))][i-1]);
}
int Get(int l, int r) {
	int k = __lg(r-l+1);
	return gcd(f[l][k], f[r-(1<<k)+1][k]);
}
\end{lstlisting}

\subsection{FHQ \space Treap}

\begin{lstlisting}
const int N = 2e5+10;
mt19937 rnd(2333);
int root, cnt, x, y, z;
struct hh{ int v, w, size, ls, rs; } tr[N];
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
void pushup(int u){ tr[u].size = 1 + tr[ls(u)].size + tr[rs(u)].size; }
int newnode(int v) { return tr[++cnt] = {v, int(rnd()), 1}, cnt; }
int merge(int x, int y) {
	if (!x || !y) return x ^ y;
	if (tr[x].w > tr[y].w) return rs(x) = merge(rs(x), y), pushup(x), x;
	return ls(y) = merge(x, ls(y)), pushup(y), y;
}
void split(int u, int v, int &x, int &y) { // <= w | > w
	if (!u) return x = y = 0, void();
	if (tr[u].v <= v) x = u, split(rs(u), v, rs(u), y);
	else y = u, split(ls(u), v, x, ls(u));
	pushup(u);
}
#undef ls
#undef rs
\end{lstlisting}

\subsection{笛卡尔树}

\begin{lstlisting}
int lc[N], rc[N], s[N], n, p;
void build () { // v: i ; w: a[i] ; root=rc[0]
	for (int i = 1;i <= n;++i) { // 大根堆则是 <
		while (p && (a[s[p]] > a[i])) p--;
		lc[i] = rc[s[p]];
		rc[s[p]] = i;
		s[++p] = i;
	}
}
\end{lstlisting}

\subsection{普通矩阵}

\begin{lstlisting}
template <size_t N, size_t M, typename T = i64>
using Mat = array<array<T, M>, N>;

template <size_t N, size_t M, typename T>
Mat<N, M, T> operator+ (const Mat<N, M, T> &a, const Mat<N, M, T> &b) {
	Mat<N, M, T> res {};
	REP(i, 0, N-1) REP(j, 0, M-1) res[i][j] = a[i][j] + b[i][j];
	return res;
}
template <size_t N, size_t M, typename T>
Mat<N, M, T> operator- (const Mat<N, M, T> &a, const Mat<N, M, T> &b) {
	Mat<N, M, T> res {};
	REP(i, 0, N-1) REP(j, 0, M-1) res[i][j] = a[i][j] - b[i][j];
	return res;
}
template <size_t N, size_t M, size_t K, typename T>
constexpr Mat<N, K, T> operator* (const Mat<N, M, T> &a, const Mat<M, K, T> &b) {
	Mat<N, K, T> res {};
	REP(i, 0, N-1) REP(j, 0, M-1) REP(k, 0, K-1)
	res[i][k] += a[i][j] * b[j][k];
	return res;
}
\end{lstlisting}

\subsection{(max, +)矩阵}

\begin{lstlisting}
template <typename Ty>
constexpr void chmax(Ty &a, Ty b) {
	if (b > a) a = b;
}
template <size_t N, typename T = i64>
using Mat = array<array<T, N>, N>;
template <size_t N, typename T>
constexpr Mat<N, T> operator* (const Mat<N, T> &a, const Mat<N, T> &b) {
	Mat<N, T> res {};
	REP(i, 0, N-1) REP(k, 0, N-1) res[i][k] = -1e16;
	REP(i, 0, N-1) REP(j, 0, N-1) REP(k, 0, K-1)
		chmax(res[i][k], a[i][j] + b[j][k]);
	return res;
}
\end{lstlisting}

\subsection{LCT}

\begin{lstlisting}
const int N = 2e5+10;
int son[N][2], fa[N], rev[N], val[N], sum[N];
bool get(int x, int p = 1) { return son[fa[x]][p] == x; }
void update(int x) {
	sum[x] = val[x] ^ sum[son[x][0]] ^ sum[son[x][1]];
}
int is_root(int x) { return !(get(x) || get(x, 0)); }
void rotate(int x) { // 注意 x y z !!!!!
	int y = fa[x], z = fa[y], b = get(x);
	if (!is_root(y)) son[z][get(y)] = x;
	son[y][b] = son[x][!b], son[x][!b] = y;
	fa[son[y][b]] = y, fa[y] = x, fa[x] = z;
	update(y);
}
void put(int x) {
	if (x) rev[x] ^= 1, swap(son[x][0], son[x][1]);
}
void down(int x) {
	if (rev[x])
	put(son[x][0]), put(son[x][1]), rev[x] = 0;
}
void pushdown(int x) {
	if (!is_root(x)) pushdown(fa[x]);
	down(x);
}
void splay(int x) {
	for (pushdown(x); !is_root(x); rotate(x))
	if (!is_root(fa[x]))
	rotate(get(x)^get(fa[x]) ? x : fa[x]);
	update(x);
}
void access(int x) {
	for (int t = 0; x; son[x][1] = t, t = x, x = fa[x])
	splay(x);
}
void mkroot(int x) {
	access(x), splay(x), put(x);
}
int find(int x) {
	access(x), splay(x);
	while (son[x][0]) x = son[x][0];
	return splay(x), x;
}
void split(int x, int y) {
	mkroot(x), access(y), splay(y);
}
void link(int x, int y) {
	mkroot(x);
	if(find(y)!=x) fa[x] = y;
}
void cut(int x, int y) {
	mkroot(x);
	if(find(y)==x && fa[y]==x && !son[y][0]){
		fa[y] = son[x][1] = 0;
		update(x);
	}
}
\end{lstlisting}

\begin{lstlisting}
if (ty == 0) {
	split(x, y);
	cout << sum[y] << "\n";
}
if (ty == 1) {
	link(x, y);
}
if (ty == 2) {
	cut(x, y);
}
if (ty == 3) {
	splay(x);
	val[x] = y;
}
\end{lstlisting}

\section{图论}

\subsection{floyd}

\begin{lstlisting}
REP(k, 1, n) REP(x, 1, n) REP(y, 1, n)
	f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
\end{lstlisting}

\subsection{dinic}

\begin{lstlisting}
const int N = 1e5+10;
const i64 INF = 2e15L;
struct Node {
	int to, at;
	i64 gap, flow;
};
vector<Node> e[N];
int cur[N], dep[N];
int n, s, t;
void Init(int nn, int ss = 0, int tt = 0) {
	n = nn, s = ss, t = tt;
	for (int i = 0; i <= n; i ++)
	e[i].clear();
}
void Add(int u, int v, i64 w, i64 rev = 0) {
	e[u].push_back({v, 0, w, 0});
	e[v].push_back({u, 0, rev, 0});
	e[u].back().at = e[v].size() - 1;
	e[v].back().at = e[u].size() - 1;
}
int Bfs() {
	fill(dep, dep+n+1, 0);
	dep[s] = 1;
	list<int> q = {s};
	while (!q.empty()) {
		auto u = q.front();
		q.pop_front();
		for (auto [v, _, g, f] : e[u]) {
			if (!dep[v] && f < g) {
				dep[v] = dep[u] + 1;
				q.push_back(v);
			}
		}
	}
	return dep[t];
}
i64 Dfs(int u, i64 fl) {
	if (u == t || fl == 0) return fl;
	i64 res = 0;
	for (int &i = cur[u]; i < e[u].size(); i ++) {
		auto [v, j, g, f] = e[u][i];
		if (dep[v] == dep[u] + 1) {
			i64 d = Dfs(v, min(fl - res, g - f));
			if (d) {
				res += d;
				e[u][i].flow += d;
				e[v][j].flow -= d;
				if (res == fl) return res;
			}
		}
	}
	return res;
}
i64 Work() {
	i64 ans = 0;
	while (Bfs()) {
		fill(cur, cur+n+1, 0);
		ans += Dfs(s, INF);
	}
	return ans;
}
\end{lstlisting}

\subsection{费用流 (EK)}

\begin{lstlisting}
using pr = pair<i64, int>;
const int N = 5e3+10;
const int M = 1e6+10;
const i64 INF = 1e16L;
struct Edge {
	int to, nxt, v, f;
} e[M<<1];
int h[N], num = 1, n, s, t;
void Add(int x, int y, int v, int f) {
	e[++num] = {y, h[x], v, f}, h[x] = num;
	e[++num] = {x, h[y], 0, -f}, h[y] = num;
}
i64 d[N], dis[N], f, c;
int vis[N], fr[N];
int Spfa() {
	queue<int> Q;
	fill(d, d+n+1, INF);
	for (d[s] = 0, vis[s] = 1, Q.push(s); Q.size(); ) {
		auto x = Q.front(); Q.pop(); vis[x] = 0;
		for (int i = h[x]; i; i = e[i].nxt) {
			if (e[i].v && d[e[i].to] > d[x] + e[i].f) {
				d[e[i].to] = d[x] + e[i].f;
				fr[e[i].to] = i;
				if (!vis[e[i].to]) vis[e[i].to] = 1, Q.push(e[i].to);
			}
		}
	}
	return d[t] < INF;
}
int Dij() {
	priority_queue<pr, vector<pr>, greater<pr>> Q;
	REP(i, 1, n) dis[i] = d[i], d[i] = INF, vis[i] = fr[i] = 0;
	for (Q.emplace(d[s] = 0, s); Q.size(); ) {
		auto x = Q.top().second; Q.pop();
		if (vis[x]) continue;
		vis[x] = 1;
		for (int i = h[x]; i; i = e[i].nxt) {
			const i64 v = e[i].f + dis[x] - dis[e[i].to];
			if (e[i].v && d[e[i].to] > d[x] + v) {
				fr[e[i].to] = i;
				Q.emplace(d[e[i].to] = d[x] + v, e[i].to);
			}
		}
	}
	for (int i = 1; i <= n; i ++) d[i] += dis[i];
	return d[t] < INF;
}
array<i64, 2> EK() {
	Spfa();
	f = c = 0;
	for (; Dij(); ) {
		i64 fl = INF;
		for (int i = fr[t]; i; i = fr[e[i^1].to])
			fl = min<i64> (e[i].v, fl);
		for (int i = fr[t]; i; i = fr[e[i^1].to])
			e[i].v -= fl, e[i^1].v += fl;
		f += fl, c += fl * d[t];
	}
	return {f, c};
}
\end{lstlisting}

\subsection{tarjan-SCC}

\begin{lstlisting}
const int N = 2e5+10;
list<int> nxt[N];
int st[N], ins[N], c[N];
int dfn[N], low[N];
vector<int> scc[N];
int n, m, tot, num, top, cnt;
void tarjan(int x) {
	dfn[x] = low[x] = ++num;
	st[++top] = x, ins[x] = 1;
	for (auto i : nxt[x]) {
		if (!dfn[i]) {
			tarjan(i); chmin(low[x], low[i]);
		}
		else if (ins[i]) chmin(low[x], dfn[i]);
	}
	if (dfn[x] == low[x]) {
		cnt ++; int y;
		do {
			y = st[top--], ins[y] = 0;
			c[y] = cnt, scc[cnt].push_back(y);
		}
		while (x != y);
	}
}
\end{lstlisting}

\subsection{tarjan-e-DCC}

\begin{lstlisting}
const int N = 5e5L+10;
// to, ind
vector<array<int, 2>> adj[N];
vector<int> scc[N];
int dfn[N], low[N], st[N], bel[N], top, n, m, cnt, tt;
void tarjan(int u, int in) {
	low[u] = dfn[u] = ++tt;
	st[++top] = u;
	for (auto [v, id] : adj[u]) {
		if (id == in) continue;
		if (!dfn[v]) {
			tarjan(v, id);
			chmin(low[u], low[v]);
		}
		else if (!bel[v]) {
			chmin(low[u], low[v]);
		}
	}
	if (dfn[u] == low[u]) {
		cnt ++;
		int z;
		do {
			z = st[top--];
			scc[cnt].push_back(z);
			bel[z] = cnt;
		}
		while (z != u);
	}
}
\end{lstlisting}

\section{Misc}

\subsection{cout精度}

\begin{lstlisting}
cout.setf(ios::fixed); cout.precision(15);
\end{lstlisting}

\subsection{read()}

\begin{lstlisting}
int read() {
	int x = 0, w = 1, ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') w = -1;
	for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';
	return x * w;
}
\end{lstlisting}

\subsection{随机相关}

\begin{lstlisting}
mt19937_64 rd(chrono::system_clock::now().time_since_epoch().count());
\end{lstlisting}

\subsection{二进制相关}

\point{遍历所有含1个数相同的数}

\begin{lstlisting}
u64 nxt(u64 x) {
	u64 b = x&(~x+1);
	u64 t = x + b;
	u64 c = t&(~t+1);
	u64 m = (c/b>>1)-1;
	return t | m;
}
/*
000111  <== enter
001011
001101
001110
......
110010
110100
111000
...... <== exit when ui64(-1)
*/
\end{lstlisting}

\point{builtin相关函数}

\texttt{\_\_builtin\_popcount(x)}: 返回x的二进制表示中1的个数。(适用于 \texttt{unsigned int})

\texttt{\_\_builtin\_popcountll(x)} 则是适用于unsigned i64

\begin{lstlisting}
int count = __builtin_popcount(65535u); // count的值为16
\end{lstlisting}

\texttt{\_\_builtin\_clz(x)}: 返回x的二进制表示中从最高位开始连续0的个数，如果x的值为0，则返回所在类型的位宽。

\begin{lstlisting}
int count = __builtin_clz(0xf00000u); // count的值为8
\end{lstlisting}

\texttt{\_\_builtin\_ctz(x)}: 返回x的二进制表示中从最低位开始连续0的个数，如果x的值为0，则返回所在类型的位宽。

\begin{lstlisting}
int count = __builtin_ctz(0xf0u); // count的值为4
\end{lstlisting}

\texttt{\_\_builtin\_parity(x)}: 返回x的二进制表示中1的个数是否为奇数，是则返回1，否则返回0。

\begin{lstlisting}
int parity = __builtin_parity(0xfu); // parity的值为1
\end{lstlisting}

\texttt{\_\_builtin\_bswap16(x)}: 将x的二进制表示中的16位进行字节交换。
\begin{lstlisting}
unsigned short y = __builtin_bswap16(0xaabb);
//                             y的值为0xbbaa
\end{lstlisting}

\texttt{\_\_builtin\_bswap32(x)}: 将x的二进制表示中的32位进行字节交换。

\begin{lstlisting}
u32 y = __builtin_bswap32(0xaabbccddU);
//                           y的值为0xddccbbaa
\end{lstlisting}

\texttt{\_\_builtin\_bswap64(x)}: 将x的二进制表示中的64位进行字节交换。
\begin{lstlisting}
u64 y = __builtin_bswap64(0xaabbccddeeff1122ULL);
//                           y的值为0x2211ffeeddccbbaa
\end{lstlisting}

\subsection{<ext/pbds/>}

\point{哈希表}

\begin{lstlisting}
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>

__gnu_pbds::gp_hash_table<int, int> mp1; // 拉链法
__gnu_pbds::cc_hash_table<int, int> mp2; // 探测法
\end{lstlisting}

\point{平衡树}

\begin{lstlisting}
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

template<class T, class TT = __gnu_pbds::null_type>
using ordered_set = __gnu_pbds::tree<
	T, TT, std::less<T>,
	__gnu_pbds::rb_tree_tag,
	// rb_tree_tag 红黑树
	// splay_tree_tag splay树
	__gnu_pbds::tree_order_statistics_node_update
	>;
\end{lstlisting}

\texttt{order\_of\_key(x)}  返回比 x 小的数的数量。

\texttt{find\_by\_order(x)}  返回排名 x 所对应元素的迭代器

\begin{lstlisting}
ordered_set<int> s;
s.insert(...); // 1, 3, 5, 7, 11
REP(i, 0, 6) cout << *s.find_by_order(i) << " "; cout << endl;
// 1, 3, 5, 7, 11, 0, 0
REP(i, 0, 12) cout << s.order_of_key(i) << " "; cout << endl;
// 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5
//   (1)   (3)   (5)   (7)         (11)
\end{lstlisting}

\texttt{split(x,b)} 按照 $x$ 分裂，小于等于 $x$ 的属于当前树，其余的属于 $b$ 树。

\texttt{join(x)} 将两颗树合并。前提是两者值域没有交集。

\point{可并堆}

\begin{lstlisting}
__gnu_pbds::priority_queue<int, less<int>, // 使用greater则是小根堆
__gnu_pbds::pairing_heap_tag> q;
// pairing_heap_tag     配对堆
// binomial_heap_tag    二项堆
// rc_binomial_heap_tag 冗余计数二项堆
// binary_heap_tag      二叉堆
// thin_heap_tag        斐波那契堆
\end{lstlisting}

\texttt{join(b)}: 把优先队列 b 合并进来并把 b 清空

\point{rope}

\begin{lstlisting}
#include <ext/rope>
__gnu_cxx::rope<char> rp = "1234";
rp.append("abcd");       // 1234abcd
rp.append('$');          // 1234abcd$
rp.replace(3, 2, "***"); // 123***bcd$
rp.append(4, ';');       // 123***bcd$;;;;
rp.erase(2, 3);          // 12*bcd$;;;;
rp.insert(6, 3, '!');    // 12*bcd!!!$;;;;
\end{lstlisting}

\subsection{多项式输出}

\begin{lstlisting}
i64 n; cin >> n; vl xishu(n+1);
REV(i, n, 0) cin >> xishu[i];
REV(i, n, 0) {
	if (xishu[i] == 0) continue;
	else if (xishu[i] < 0)
	cout << '-', xishu[i] = -xishu[i];
	else if (xishu[i] > 0 && i != n)
	cout << '+';
	if (xishu[i] != 1 || i == 0)
	cout << xishu[i];
	if (i > 1) cout << 'x' << '^' << i;
	else if (i == 1) cout << 'x';
} cout << endl;
\end{lstlisting}

\subsection{日期}

\begin{lstlisting}
int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
struct Date {
	int year, month, day;
};
//判闰年	
inline int leap(int year) {
	return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
}
//判合法性
inline int legal(Date a) {
	if (a.month < 0 || a.month>12)
	return 0;
	if (a.month == 2)
	return a.day > 0 && a.day <= 28 + leap(a.year);
	return a.day > 0 && a.day <= days[a.month - 1];
}
//比较日期大小
inline int datecmp(Date a, Date b) {
	if (a.year != b.year)
	return a.year - b.year;
	if (a.month != b.month)
	return a.month - b.month;
	return a.day - b.day;
}
//返回指定日期是星期几
int weekday(Date a) {
	int tm = a.month >= 3 ? (a.month - 2) : (a.month + 10);
	int ty = a.month >= 3 ? a.year : (a.year - 1);
	return (ty + ty / 4 - ty / 100 + ty / 400 + (int)(2.6 * tm - 0.2) + a.day) % 7;
}
//日期转天数偏移
int date2int(Date a) {
	int ret = a.year * 365 + (a.year - 1) / 4 - (a.year - 1) / 100 + (a.year - 1) / 400;
	days[1] += leap(a.year);
	for (int i = 0; i < a.month - 1; ret += days[i++]);
	days[1] = 28;
	return ret + a.day;
}
//天数偏移转日期
Date int2date(int a) {
	Date ret = {0, 0, 0};
	ret.year = a / 146097 * 400;
	for (a %= 146097; a >= 365 + leap(ret.year); a -= 365 + leap(ret.year), ret.year++);
	days[1] += leap(ret.year);
	for (ret.month = 1; a >= days[ret.month - 1]; a -= days[ret.month - 1], ret.month++);
	days[1] = 28;
	ret.day = a + 1;
	return ret;
}
\end{lstlisting}

\begin{lstlisting}
auto E_is_leap = [&] (int y) -> int {
	if (y % 400 == 0) return 1;
	if (y % 100 == 0) return 0;
	if (y % 4 == 0) return 1;
	return 0;
};
vector<int> E_days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
auto E_days_in_month = [&] (int y, int m) -> int {
	assert(1 <= m && m <= 12);
	if (m == 2 && E_is_leap(y)) return E_days[m] + 1;
	return E_days[m];
};
vector<int> E_days_presum(13);
REP(i, 1, 12) {
	E_days_presum[i] = E_days_presum[i-1] + E_days[i];
}
auto E_days_before_month = [&] (int y, int m) -> int {
	if (E_is_leap(y) && m >= 3) return E_days_presum[m-1] + 1;
	return E_days_presum[m-1];
};
auto E_days_before_day = [&] (int y, int m, int d) {
	return E_days_before_month(y, m) + d - 1;
};
auto E_days_before_year = [&] (int y) {
	y --;
	return y*365 + y/4 - y/100 + y/400;
};
auto E_get_ord = [&] (int y, int m, int d) {
	return E_days_before_year(y) + E_days_before_day(y, m, d);
};
constexpr i64 E_seconds_in_day = 1ll * 24 * 60 * 60;
auto E_get_ts = [&] (int Y, int m, int d, int H, int M, int S) -> i64 {
	return E_get_ord(Y, m, d) * E_seconds_in_day
	+ 1ll * 60 * 60 * H
	+ 1ll * 60 * M
	+ 1ll * S;
};
// cout << E_get_ts(2024, 11, 11, 0, 0, 0)
//	  - E_get_ts(1970, 1, 1, 0, 0, 0) << endl;
auto M_is_leap = [&] (int y) -> int {
	if (y % 1000 == 0) return 1;
	if (y % 100 == 0) return 0;
	if (y % 10 == 0) return 1;
	if (y % 2 == 1) return 1;
	return 0;
};
auto M_days_in_month = [&] (int y, int m) -> int {
	assert(1 <= m && m <= 24);
	if (m == 24 && M_is_leap(y)) return 28;
	if (m % 6 == 0) return 27;
	return 28;
};
vector<int> M_days = {0, 28, 28, 28, 28, 28, 27, 28, 28, 28, 28, 28, 27, 28, 28, 28, 28, 28, 27, 28, 28, 28, 28, 28, 27};
vector<int> M_days_presum(25);
REP(i, 1, 24) {
	M_days_presum[i] = M_days_presum[i-1] + M_days[i];
}
auto M_days_before_month = [&] (int y, int m) -> int {
	return M_days_presum[m-1];
};
auto M_days_before_day = [&] (int y, int m, int d) {
	return M_days_before_month(y, m) + d - 1;
};
auto M_days_before_year = [&] (int y) {
	y --;
	return (y+1)*669 - y/2 + y/10 - y/100 + y/1000;
};
auto M_get_ord = [&] (int y, int m, int d) {
	return M_days_before_year(y) + M_days_before_day(y, m, d);
};
constexpr i64 M_seconds_in_day = 1ll * 24 * 60 * 60;
auto M_get_ts = [&] (int Y, int m, int d, int H, int M, int S) -> i64 {
	return M_get_ord(Y, m, d) * M_seconds_in_day
	+ 1ll * 60 * 60 * H
	+ 1ll * 60 * M
	+ 1ll * S;
};
auto M_ord_to_ymd = [&] (int ts) -> array<int, 3> {
	int year = int(floor(db(ts)/668.59L));
	if (ts <= M_days_before_year(year)) year --;
	else if (ts > M_days_before_year(year+1)) year ++;
	ts -= M_days_before_year(year);
	int month = ts / 28 + 1;
	if (ts <= M_days_before_month(year, month)) month --;
	else if (month < 24 && ts > M_days_before_month(year, month+1))
	month ++;
	ts -= M_days_before_month(year, month);
	return {year, month, ts};
};
constexpr db _1SOL = 88775.244147L;  // unit: terrestrial second
constexpr db _M2EC = _1SOL/86400.L;  // 1sol / 1day
constexpr db _E2MC = 86400.L/_1SOL;  // 1day / 1sol
auto E2M = [&] (int Y, int m, int d, int H, int M, int S) -> array<int, 6> {
	db E_ts = E_get_ts(Y, m, d, H, M, S)
	- E_get_ts(1609, 3, 11, 18, 40, 34);
	db M_ts = E_ts / _1SOL;
	db M_time = fmodl(M_ts, 1.L);
	db M_date = M_ts - M_time + 1.L;
	M_time *= M_seconds_in_day;
	auto [x, y, z] = M_ord_to_ymd(M_date);
	int M_time_int = int(M_time);
	int c = M_time_int % 60;
	M_time_int /= 60;
	int b = M_time_int % 60;
	M_time_int /= 60;
	int a = M_time_int;
	return {x, y, z, a, b, c};
};
char tmp;
int Y, m, d, H, M, S;
cin >> Y >> tmp >> m >> tmp >> d;
cin >> H >> tmp >> M >> tmp >> S;
auto [x, y, z, a, b, c] = E2M(Y, m, d, H, M, S);
printf("%04d-%02d-%02d %02d:%02d:%02d\n", x, y, z, a, b, c);
\end{lstlisting}

\subsection{快速排序}

\begin{lstlisting}
mt19937 rnd(random_device{} ());
static void qs(int l, int r) {
	if (l >= r) return;
	swap(a[l], a[l + rnd() % (r-l+1)]);
	int pivot = a[l], i = l, j = r;
	while (i < j) {
		while (i < j && a[j] > pivot) --j;
		if (i < j) a[i++] = a[j];
		while (i < j && a[i] < pivot) ++i;
		if (i < j) a[j--] = a[i];
	}
	a[i] = pivot; qs(l, i-1); qs(i+1, r);
}
\end{lstlisting}

\subsection{火车头精简版}

\begin{lstlisting}
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
#pragma GCC optimize("inline")
#pragma pack(1)
\end{lstlisting}

\subsection{导数积分}

\textbf{
\small\bfseries
\begin{align*}
\left(\frac{u}{v}\right)' &= \frac{u'v-uv'}{v^2}  &  (\arctan (x))' &= \frac{1}{1+x^2}                    & (\mathrm{arcsinh} (x))' &= \frac{1}{\sqrt{1+x^2}}               \\
(a^x)' &= (\ln a)a^x                              &  (\mathrm{arccot} (x))' &= -\frac{1}{1+x^2}           & (\mathrm{arccosh} (x))' &= \frac{1}{\sqrt{x^2-1}}               \\
(\tan (x))' &= \sec^2 (x)                         &  (\mathrm{arcsec} (x))' &= \frac{1}{|x|\sqrt{x^2-1}}  & (\mathrm{arctanh} (x))' &= \frac{1}{1-x^2}                      \\
(\cot (x))' &= -\csc^2 (x)                        &  (\mathrm{arccsc} (x))' &= -\frac{1}{|x|\sqrt{x^2-1}} & (\mathrm{arccoth} (x))' &= \frac{1}{1-x^2}                      \\
(\sec (x))' &= \tan (x) \sec (x)                  &  (\tanh (x))' &= \mathrm{sech}^2 (x)                  & (\mathrm{arcsech} (x))' &= -\frac{1}{x\sqrt{1-x^2}}             \\
(\csc (x))' &= -\cot (x) \csc (x)                 &  (\coth (x))' &= -\mathrm{csch}^2 (x)                 & (\mathrm{arccsch} (x))' &= -\frac{1}{|x|\sqrt{1+x^2}}           \\
(\arcsin (x))' &= \frac{1}{\sqrt{1-x^2}}          &  (\mathrm{sech} (x))' &= -\mathrm{sech} (x) \tanh (x) &                         &                                       \\
(\arccos (x))' &= -\frac{1}{\sqrt{1-x^2}}         &  (\mathrm{csch} (x))' &= -\mathrm{csch} (x) \coth (x) &                         &                                       \\
\end{align*}
}

{
\Large
$ax^2 + bx + c(a > 0)$

\Large
$$ \int\frac{dx}{ax^2+bx+c} = \begin{cases}
	\frac{2}{\sqrt{4ac-b^2}}\arctan\frac{2ax+b}{\sqrt{4ac-b^2}}+C & (b^2 < 4ac) \\
	\frac{1}{\sqrt{b^2-4ac}}\ln\left|\frac{2ax+b-\sqrt{b^2-4ac}}{2ax+b+\sqrt{b^2-4ac}}\right|+C & (b^2 > 4ac)
\end{cases} $$

$$ \int\frac{x}{ax^2+bx+c}dx = \frac{1}{2a}\ln|ax^2+bx+c|-\frac{b}{2a}\int\frac{dx}{ax^2+bx+c} $$

}

\subsection{STL 积分/求和}

{
\Large
$$ \int_0^1 t^{x-1}(1-t)^{y-1}\,dt = \mathrm{beta}(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)} $$

$$ \int_0^{+\infty} t^{num-1}e^{-t}\,dt = \mathrm{tgamma}(num) = e^{\mathrm{lgamma}(num)}$$

$$ \int_0^{phi} \frac{d\theta}{\sqrt{1-k^2\sin^2\theta}} = \mathrm{ellint\_1}(k,phi) $$

$$ \int_0^{phi} \sqrt{1-k^2\sin^2\theta}\,d\theta = \mathrm{ellint\_2}(k,phi) $$

$$ \int_{num}^{+\infty} \frac{e^{-t}}{t}\,dt = -\mathrm{expint}(-num) $$

$$ \sum_{n=1}^{+\infty} n^{-num} = \mathrm{riemann\_zeta}(num) $$

$$ \frac{2}{\sqrt{\pi}}\int_0^{arg} e^{-t^2}\,dt = \mathrm{erf}(arg) $$

$$ J_{\alpha} (x) = \sum_{m = 0}^{\infty} \frac{(-1)^m}{m ! \Gamma (m + \alpha + 1)} \left(\frac{x}{2}\right) ^ {(2 m + \alpha)} = \mathrm{jn} (\alpha, x) $$

$$ Y_{\alpha} (x) = \frac{J_{\alpha} (x) \cos (\alpha \pi) - J_{ - \alpha} (x)}{\sin (\alpha \pi)} = \mathrm{yn} (\alpha, x) $$

}

\subsection{其他公式}

{
\Large
$$ d(i \cdot j) = \sum_{x | i} \sum_{y | j} [\gcd (x, y) = 1] = \sum_{p \mid \gcd (i, j)} \mu (p) \cdot d (\frac{i}{p}) \cdot d (\frac{j}{p}) $$

$$ \epsilon (x) = \sum \limits_{d \mid x} \mu (d) $$
}

\subsection{bashrc}

\begin{lstlisting}
mk() { local F="$1" ; shift ; g++ "$F.cpp" -o "$F" "$@"; }
ulimit -s 1048576
ulimit -v 1048576
\end{lstlisting}

\subsection{Xor \space Shift}

\begin{lstlisting}
u64 xorshift(u64 x) { x ^= x << 13; x ^= x >> 7; x ^= x << 17; return x; }
u32 xorshift(u32 x) { x ^= x << 13; x ^= x >> 17; x ^= x << 5; return x; }
\end{lstlisting}

\subsection{质数表}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
2 & 3 & 5 & 7 & 11 & 13 & 17 & 19 & 23 & 29\\
\hline
31 & 37 & 41 & 43 & 47 & 53 & 59 & 61 & 67 & 71\\
\hline
73 & 79 & 83 & 89 & 97 & 101 & 103 & 107 & 109 & 113\\
\hline
127 & 131 & 137 & 139 & 149 & 151 & 157 & 163 & 167 & 173\\
\hline
179 & 181 & 191 & 193 & 197 & 199 & 211 & 223 & 227 & 229\\
\hline
233 & 239 & 241 & 251 & 257 & 263 & 269 & 271 & 277 & 281\\
\hline
283 & 293 & 307 & 311 & 313 & 317 & 331 & 337 & 347 & 349\\
\hline
353 & 359 & 367 & 373 & 379 & 383 & 389 & 397 & 401 & 409\\
\hline
419 & 421 & 431 & 433 & 439 & 443 & 449 & 457 & 461 & 463\\
\hline
467 & 479 & 487 & 491 & 499 & 503 & 509 & 521 & 523 & 541\\
\hline
547 & 557 & 563 & 569 & 571 & 577 & 587 & 593 & 599 & 601\\
\hline
607 & 613 & 617 & 619 & 631 & 641 & 643 & 647 & 653 & 659\\
\hline
661 & 673 & 677 & 683 & 691 & 701 & 709 & 719 & 727 & 733\\
\hline
739 & 743 & 751 & 757 & 761 & 769 & 773 & 787 & 797 & 809\\
\hline
811 & 821 & 823 & 827 & 829 & 839 & 853 & 857 & 859 & 863\\
\hline
877 & 881 & 883 & 887 & 907 & 911 & 919 & 929 & 937 & 941\\
\hline
947 & 953 & 967 & 971 & 977 & 983 & 991 & 997 & 1009 & 1013\\
\hline
\end{tabular}


%\subsection{}
%
%\begin{lstlisting}
%
%\end{lstlisting}


\end{document}
