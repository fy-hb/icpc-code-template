\documentclass[a4paper,landscape,twocolumn]{ctexart}
\usepackage[Glenn]{fncychap}
\usepackage[procnames]{listings}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{lastpage}
\usepackage[UTF8]{ctex}
%\usepackage{minted}
\usepackage{relsize}
%\usepackage{CJKutf8}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage {epigraph}
\usepackage {expdlist}
\usepackage {graphicx}

%\setmainfont{LXGW WenKai}
\setmainfont{Source Han Serif CN SemiBold}
%\setmathrm{Source Han Serif CN SemiBold}
%\setmathsf{Source Han Serif CN SemiBold}
%\setmathtt{Source Han Serif CN SemiBold}
\setsansfont{WenQuanYi Micro Hei}
\setmonofont{JetBrains Mono NL}
\setCJKmainfont{Source Han Serif CN}
%\setCJKmainfont{LXGW WenKai}
%\setCJKmainfont{WenQuanYi Micro Hei}

\geometry{left=1cm,right=1cm,top=1.5cm,bottom=1.5cm}
%\setCJKmainfont{SimSun}

% 调整列间距（可选）
\setlength{\columnsep}{0.4cm}
%\setlength\columnseprule{0.4pt}
%\setCJKmainfont{SimSun}

\def\KWauthor{frost\_ice @ HEU}
\def\KWtitle{Code Template}

\title{\textlarger[10]{\KWtitle}}
\author{\KWauthor}
%\date{2024年12月}

% 定义目录格式
\makeatletter
\renewcommand\tableofcontents{%
	\section*{\makebox[\linewidth][c]{\contentsname}%
		\@mkboth{\MakeUppercase\contentsname}{\MakeUppercase\contentsname}}%
	\begin{multicols}{2}%
		\@starttoc{toc}%
	\end{multicols}
}
\makeatother

% 代码高亮的基本颜色设置
\definecolor{mygreen}{RGB}{28,172,0}
\definecolor{mylilas}{RGB}{170,55,241}
\definecolor{mygray}{RGB}{128,128,128}
\definecolor{mymauve}{RGB}{124,6,123}
\definecolor{myblue}{RGB}{14,84,175}
\definecolor{mybg}{RGB}{248,248,248}

% 代码样式设置
\lstset{
	language=C++,                           % 设置语言
	basicstyle=\small\ttfamily,             % 基本代码风格
	columns=fixed,                          %
	numbers=left,                           % 行号的位置在左边
	numberstyle=\small\color{mygray},       % 行号的样式
	stepnumber=1,                           % 行号的步进值
	numbersep=5pt,                          % 行号的距离
%	backgroundcolor=\color{mybg},           % 代码块背景色
	showspaces=false,                       % 不显示空格
	showstringspaces=false,                 % 不显示字符串中的空格
	showtabs=false,                         % 不显示制表符
	frame=single,                           % 显示框架
	rulecolor=\color{black},                % 框架颜色
	tabsize=2,                              % 制表符长度
	captionpos=t,                           % 标题位置 t=top
	breaklines=true,                        % 自动换行
%	breakatwhitespace=true,                 % 只在空格处换行
	postbreak=\raisebox{0ex}[0ex][0ex]      % 换行的样式
		{\ensuremath{\hookrightarrow}\space},
	commentstyle=\color{mygreen}\CJKfontspec{WenQuanYi Micro Hei Mono},
								            % 注释的样式
	keywordstyle={\bfseries\color{blue}},   % 关键字的样式
	stringstyle=\color{mymauve},            % 字符串样式
	escapeinside={(*@}{@*)},                % 特殊符号
	morekeywords={constexpr,REP,REV,*,...}, % 更多的关键字
	deletekeywords={...},                   % 删除默认的关键字
	% 完整的边框
	xleftmargin=2em,                        % 左边距
%	xrightmargin=2em,                       % 右边距
%	aboveskip=1em,                          % 上边距
%	belowskip=1em,                          % 下边距
	% 增强的关键字
	emph={int,char,double,float,unsigned,void,bool,i64,u64,i32,u32,db,cp,long},
	emphstyle={\bfseries\color{mymauve}},
	% 标识符样式
	identifierstyle=\color{black},
}

\newcommand{\point}[1]{
	\begin{itemize}
		\item \textbf{#1}
	\end{itemize}
}

\begin{document}

\newgeometry{left=1cm,right=1cm,top=1.5cm,bottom=1.5cm}
\begin{titlepage}
\thispagestyle{plain}
\thispagestyle{empty}
\begin{center}
	~\\[100pt]
	\hrule\ \\[8pt]
	\fontsize{48pt}{\baselineskip}\selectfont  \textsc{\KWtitle}\\[8pt]
	~\\[20pt]
%		\includegraphics[scale=1]{./cover.jpg}
	~\\[50pt]
	\huge \KWauthor\\[8pt]
	\Large Last build at \today
	~\\[100pt]
	\hrule\ \\[8pt]
\end{center}
\pagebreak
%\pagestyle{plain}
\pagestyle{fancy}
\lhead{}
\rhead{}
\chead{\KWtitle, \KWauthor}
\cfoot{}
\tableofcontents
\end{titlepage}
\restoregeometry

\pagestyle{fancy}

\pagestyle{fancy}
\lhead{\large\KWtitle, \KWauthor}
\chead{}
\rhead{\Huge\bfseries\thepage}
\lfoot{}
\cfoot{第 \thepage 页 - 共 \pageref{LastPage} 页}
\rfoot{}


\section{数论}

\subsection{ExGcd}

\begin{lstlisting}[]
// result : -b < x < b AND -a < y <= a when a,b != 0
i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {
	if (b == 0) { x = 1, y = 0; return a; }
	i64 d = exgcd(b, a % b, y, x);
	y -= a / b * x; return d;
}
\end{lstlisting}

\begin{lstlisting}[]
array<int, 3> exgcd(int a, int b) {
	if (!b) return {a, 1, 0};
	auto [d, x, y] = exgcd(b, a % b);
	return {d, y, x - y * (a / b)};
}
\end{lstlisting}

\subsection{euler\_phi}

\begin{lstlisting}[]
int euler_phi(int n) {
	int ans = n;
	for (int i = 2; i * i <= n; i++)
		if (n % i == 0) {
			ans = ans / i * (i - 1);
			while (n % i == 0) n /= i;
		}
	if (n > 1) ans = ans / n * (n - 1);
	return ans;
}
\end{lstlisting}

\subsection{预处理逆元}

\begin{lstlisting}[]
inv[1] = 1; REP(i, 2, n) inv[i] = (mod - mod/i) * inv[mod%i] % mod;
\end{lstlisting}

\subsection{线性筛}

\begin{lstlisting}[]
const int N = 1e5+10;
bitset<N> vis;
vector<int> primes;
// Mobius函数, 欧拉函数
int mu[N], phi[N];
// 约数个数, 最小质因子数量
int d[N], num[N];
// 约数和, 最小质因子的p^0+p^1+...+p^k
int f[N], g[N];
static inline void Init(int n) {
	vis[1] = 1;
	mu[1] = 1;
	phi[1] = 1;
	d[1] = 1, num[1] = 0;
	g[1] = f[1] = 1;
	for (int i = 2; i <= n; i ++) {
		if (!vis[i]) {
			primes.push_back(i);
			mu[i] = -1;
			phi[i] = i-1;
			num[i] = 1, d[i] = 2;
			g[1] = f[1] = i+1;
		}
		for (auto j : primes) {
			if (i*j > n) break;
			vis[i*j] = 1;
			mu[i*j] = -mu[i];
			phi[i*j] = phi[i]*phi[j];
			num[i*j] = 1, d[i*j] = d[i]<<1;
			g[i*j] = j+1, f[i*j] = f[i]*f[j];
			if (i%j == 0) {
				mu[i*j] = 0;
				phi[i*j] = phi[i]*j;
				num[i*j] = num[i]+1, d[i*j] = d[i] / (num[i]+1) * (num[i]+2);
				g[i*j] = g[i]*j+1, f[i*j] = f[i] / g[i] * g[i*j];
				break;
			}
		}
	}
}
\end{lstlisting}

\subsection{Miller–Rabin}

\begin{lstlisting}[]
int millerRabin(i64 n) {
	if (n < 3 || n % 2 == 0) return n == 2;
	i64 u = n - 1, t = 0;
	while (u % 2 == 0) u /= 2, ++t;
	for (i64 i = 0; i < test_time; ++i) {
		i64 a = rand() % (n-2) + 2, v = qpow(a, u, n);
		if (v == 1) continue;
		for (i64 s = 0; s < t; ++s) {
			if (v == n-1) break;
			if (s == t-1) return 0;
			v = i64(v) * v % n;
		}
	}
	return 1;
}
\end{lstlisting}

\begin{lstlisting}
i64 mul(i64 a, i64 b, i64 p) {
	i64 z = a * (db(1) / p) * b + 0.5L;
	i64 res = a * b - z * p;
	return res + (res >> 63 & p);
}
i64 qpow(i64 x, i64 y, i64 p, i64 res = 1) {
	for (; y; y >>= 1, x = mul(x, x, p))
		if (y & 1) res = mul(res, x, p);
	return res;
}
int MR(i64 p) {
	if (p == 1) return 0;
	i64 d = __builtin_ctzll(p - 1), s = (p - 1) >> d;
	for (auto a : {2, 3, 5, 7, 11, 13, 82, 373}) {
		if (a % p == 0) continue;
		i64 x = qpow(a, s, p), y;
		for (int i = 0; i < d; ++i, x = y) {
			y = mul(x, x, p);
			if (y == 1 && x != 1 && x != p - 1)
				return 0;
		}
		if (x != 1) return 0;
	}
	return 1;
}
i64 PR(i64 p) { // p > 1 && not prime
	if (!(p & 1)) return 2;
	i64 x = 0, y = 0, pp = 1;
	auto f = [p](i64 o) { return mul(o, o, p) + 1; };
	for (int t = 30, z = 0; t % 64 || gcd(pp, p) == 1; t ++) {
		if (x == y) x = ++z, y = f(x);
		if (i64 q = mul(pp, x + p - y, p)) pp = q;
		x = f(x), y = f(f(y));
	}
	return gcd(pp, p);
}
\end{lstlisting}

\subsection{Mint}

\begin{lstlisting}[]
constexpr int mod = 998'244'353;
constexpr int Normal(int x, int m = mod) { return x<0&&(x+=m), x; }
constexpr int qpow(int x, int y, int m = mod, int ans = 1) {
	for (; y; y >>= 1, x = (u64) x * x % m)
		if (y & 1) ans = (u64) ans * x % m;
	return ans;
}
struct Mint {
	int val;
	constexpr Mint(i64 x = 0) : val(Normal(x % mod)) {}
};
constexpr Mint Pow(Mint a, i64 p) { return qpow(a.val, Normal(p, mod-1)); }
constexpr Mint Inv(Mint a) { return Pow(a, -1); }
constexpr Mint operator- (Mint a) { return mod-a.val; }
constexpr Mint operator+ (Mint a, Mint b) { return a.val + b.val; }
constexpr Mint operator- (Mint a, Mint b) { return a.val - b.val; }
constexpr Mint operator* (Mint a, Mint b) { return 1ll * a.val * b.val; }
constexpr Mint operator/ (Mint a, Mint b) { return 1ll * a.val * Inv(b); }
constexpr Mint& operator+= (Mint &a, Mint b) { return a = a + b; }
constexpr Mint& operator-= (Mint &a, Mint b) { return a = a - b; }
constexpr Mint& operator*= (Mint &a, Mint b) { return a = a * b; }
constexpr Mint& operator/= (Mint &a, Mint b) { return a = a / b; }
constexpr Mint& operator++ (Mint &a) { return a += 1; }
constexpr Mint& operator-- (Mint &a) { return a -= 1; }
constexpr Mint operator++ (Mint &a, int) { auto b = a; return a += 1, b; }
constexpr Mint operator-- (Mint &a, int) { auto b = a; return a -= 1, b; }
template <typename S> S& operator<< (S &s, Mint a) { return s << a.val; }
constexpr bool operator== (Mint a, Mint b) { return a.val == b.val; }
constexpr Mint operator "" _M (unsigned long long x) { return x; }
\end{lstlisting}

\subsection{二次剩余}

\begin{lstlisting}
array<int, 2> res2(int n, int p) {
	if (!n) return {0, 0};
	if (qpow(n, p / 2, p) != 1) return {-1, -1};
	int t, ii; static mt19937_64 rnd(114514);
	do t = rnd() % p, ii = ((u64) t * t + p - n) % p;
	while (qpow(ii, p / 2, p) != p - 1);
	array<int, 2> ans = {1, 0}, x = {t, 1};
	auto mul = [ii, p] (array<int, 2> x, array<int, 2> y) -> array<int, 2> {
		return {int(((u64) x[0] * y[0] + (u64) x[1] * y[1] % p * ii) % p),
					int(((u64) x[0] * y[1] + (u64) x[1] * y[0]) % p)}; };
	for (int y = p / 2 + 1; y; y >>= 1, x = mul(x, x))
		if (y & 1) ans = mul(ans, x);
	return {min(ans[0], p - ans[0]), max(ans[0], p - ans[0])};
}
\end{lstlisting}

\subsection{Poly}

\begin{lstlisting}
constexpr int mod = 998'244'353;
constexpr int qpow(int x, int y, int m = mod, int ans = 1) {
	for (; y; y >>= 1, x = (u64) x * x % m)
		if (y & 1) ans = (u64) ans * x % m;
	return ans;
}
using P = vector<int>;
vector<int> rev, wn;
int lim, invlim;
void init(int n) {
	lim = max(2 << __lg(n - 1), 1);
	invlim = mod - (mod - 1) / lim;
	if (lim > wn.size()) wn.resize(lim);
	rev.resize(lim);
	for (static int i = 1; i < lim; i <<= 1) {
		int w = qpow(3, mod / i / 2), cur = 1;
		for (int j = 0; j < i; j ++)
			wn[i+j] = cur, cur = (u64) cur * w % mod;
	}
	REP(i, 1, lim-1) rev[i] = rev[i>>1] >> 1 | (i&1 ? lim>>1 : 0);
}
P trunc(const P &a, int siz) {
	if (siz <= a.size()) return P(a.begin(), a.begin() + siz);
	P res = a; res.resize(siz); return res;
}
P reverse(const P &v) { return P(v.rbegin(), v.rend()); }
P dft(const P &a) {
	static vector<u64> tmp;
	tmp.assign(lim, 0);
	REP(i, 0, a.size()-1) tmp[rev[i]] = a[i];
	for (int i = 1; i < lim; i <<= 1) {
		for (int k = i & (1 << 19); k--; )
			if (tmp[k] >= mod * 9ull) tmp[k] -= mod * 9ull;
		for (int j = 0; j < lim; j += 2 * i)
			for (int k = 0; k < i; k ++) {
				const u64 x = (u64) tmp[i+j+k] * wn[i+k] % mod;
				tmp[i+j+k] = tmp[k+j] + mod - x; tmp[k+j] += x;
			}
	}
	REP(i, 0, lim-1) tmp[i] %= mod;
	return P(tmp.begin(), tmp.end());
}
P idft(const P &a) {
	auto b = dft(a); reverse(b.begin()+1, b.end());
	for (auto &i : b) i = (u64) i * invlim % mod;
	return b;
}
P operator- (const P &a) {
	P c = a;
	for (auto &i : c) i = i ? mod - i : 0;
	return c;
}
P operator+ (const P &a, const P &b) {
	P c(max(a.size(), b.size()));
	REP(i, 0, a.size()-1) c[i] += a[i];
	REP(i, 0, b.size()-1) c[i] += b[i], c[i] >= mod && (c[i] -= mod);
	return c;
}
P operator- (const P &a, const P &b) {
	return a + (-b);
}
P operator* (const P &a, const P &b) {
	assert(a.size() && b.size());
	int l = a.size() + b.size() - 1;
	init(l);
	auto c = dft(a), d = dft(b);
	REP(i, 0, lim-1) c[i] = (u64) c[i] * d[i] % mod;
	auto res = idft(c);
	return trunc(res, l);
}
P operator* (const P &a, int b) {
	auto x = trunc(a, a.size());
	for (auto &i : x) i = (u64) i * b % mod;
	return x;
}
P inv(const P &a) { // inv(a) (mod x^n)
	int n = a.size();
	P x = {qpow(a[0], mod-2)};
	for (int t = 2; t < 2 * n; t <<= 1)
		x = trunc((P {2} - trunc(a, t) * x) * x, t);
	return trunc(x, n);
}
pair<P, P> div(const P &f, const P &g) { // f = g * q + r
	int n = f.size(), m = g.size();
	auto q = reverse(trunc(reverse(f) * inv(trunc(reverse(g), n-m+1)), n-m+1));
	auto r = trunc(f - g * q, m - 1);
	return {q, r};
}
P sqrt(const P &a) { // sqrt(a) (mod x^n);
	P b {res2(a[0], mod)[0]};
	if (b[0] < 0) return {};
	int n = a.size();
	for (int t = 2; t < 2 * n; t <<= 1)
		b = trunc((trunc(a, t) + b * b) * inv(trunc(b * 2, t)), t);
	return trunc(b, n);
}
P deriv(const P &a) {
	int n = a.size(); if (!n) return {}; P res(n - 1);
	REP(i, 0, n-2) res[i] = (u64) a[i + 1] * (i + 1) % mod;
	return res;
}
P integr(const P &a) {
	int n = a.size(); P res(n + 1);
	REP(i, 1, n) res[i] = (u64) a[i - 1] * qpow(i, mod-2, mod) % mod;
	return res;
}
P log(const P &a) {
	return trunc(integr(deriv(a) * inv(a)), a.size());
}
P exp(const P &a) {
	int n = a.size(); P b {1};
	for (int t = 2; t < 2 * n; t <<= 1)
		b = trunc(b * (P {1} - log(trunc(b, t)) + trunc(a, t)), t);
	return trunc(b, n);
}
\end{lstlisting}

\section{数学}

\subsection{遍历所有素勾股数}

\begin{lstlisting}
void gen(int a, int b, int c) { // a < b
    gen( a + 2*b + 2*c,  2*a + b + 2*c,  2*a + 2*b + 3*c);
    gen(-a + 2*b + 2*c, -2*a + b + 2*c, -2*a + 2*b + 3*c);
    gen( a - 2*b + 2*c,  2*a - b + 2*c,  2*a - 2*b + 3*c);
} // 用法: gen(3, 4, 5);
\end{lstlisting}

\subsection{组合数}

\begin{lstlisting}
i64 fac[N], inv[N];
static inline void Init(i64 n) {
	fac[0] = 1;
	REP(i, 1, n)
		fac[i] = fac[i-1] * i % mod;
	inv[n] = qpow(fac[n], mod - 2);
	REV(i, n, 1)
		inv[i-1] = inv[i] * i % mod;
}
static inline i64 C(i64 x, i64 y) {
	if (y > x || y < 0) return 0;
	return (fac[x]*inv[y]%mod)*inv[x-y] % mod;
}
\end{lstlisting}

\subsection{组合数学相关}

\begin{lstlisting}[]
// c[p]中 i个元素>=k的方案数.
inline i64 calc(i64 p, i64 m, i64 k, i64 i) {
	if (i * k > m || i > p) return 0;
	return (C(p, i) * C(m-i*k+p-1, p-1) % mod + mod - calc(p, m, k, i+1)) % mod;
}
\end{lstlisting}

\subsection{小球装盒问题}

\renewcommand{\arraystretch}{1.5}
\begin{tabular}{|c|c|c|c|}
	\hline
	k 个球 & m 个盒子 & 允许有空 & 方案数 \\
	\hline
	\multirow{4}{*}[0em]{各不相同} & \multirow{2}{*}[0em]{各不相同} & 是 & \Large$m ^ k$ \\
	\cline{3-4}
	& & 否 & \Large$m ! \cdot St2 (k, m)$ \\
	\cline{2-4}
	& \multirow{2}{*}[0em]{完全相同} & 是 & \Large$\sum_{i=1}^{m} {St2 (k, i)}$ \\
	\cline{3-4}
	& & 否 & \Large$St2 (k, m)$ \\
	\hline
	\multirow{4}{*}[0em]{完全相同} & \multirow{2}{*}[0em]{各不相同} & 是 & \Large$C (m + k - 1, m-1)$ \\
	\cline{3-4}
	& & 否 & \Large$C (k-1, m-1)$ \\
	\cline{2-4}
	& \multirow{2}{*}[0em]{完全相同} & 是 & \Large$[x^k] \prod_{i=1}^{m} \frac{1}{1 - x ^ i}$ \\
	\cline{3-4}
	& & 否 & \Large$ [x^k] \prod_{i=1}^{m} \frac{x ^ m}{1 - x ^ i} $ \\
	\hline
\end{tabular}

\subsection{FFT}

\begin{lstlisting}
using db = long double;
// cp::real  cp::imag  std::conj  std::arg
using cp = complex<db>;
const db PI = acos(-1.L);
const int N = 4e6+10;
int rev[N], lim;
cp wn[N];
void init(int siz) {
	lim = 2 << __lg(siz - 1);
	for (static int i = 1; i < lim; i <<= 1)
		for (int j = 0; j < i; j ++)
			wn[i+j] = polar(1.L, db(j) / db(i) * PI);
	for (int i = 1; i < lim; i ++)
		rev[i] = rev[i>>1] >> 1 | (i & 1 ? lim >> 1 : 0);
}
void dft(cp* a) {
	for (int i = 0; i < lim; i ++)
		if (rev[i] < i) swap(a[rev[i]], a[i]);
	for (int i = 1; i < lim; i <<= 1)
		for (int j = 0; j < lim; j += 2*i)
			for (int k = 0; k < i; k ++) {
				cp x = a[k+j] - a[i+j+k] * w[i+k];
				cp y = a[k+j] + a[i+j+k] * w[i+k];
				a[i+j+k] = x, a[k+j] = y;
			}
}
void idft(cp* a) {
	dft(a); reverse(a+1, a+lim);
	for (int i = 0; i < lim; i ++)
		a[i] /= lim;
}
\end{lstlisting}

\subsection{FMT / 或卷积}

\begin{lstlisting}
void fmt(int* a) {
	// n = 1 << d
	REP(i, 0, d-1) REP(j, 0, n-1) if (j&(1<<i))
		// ifmt: a[j] -= a[j^(1<<i)];
		a[j] += a[j^(1<<i)];
}
\end{lstlisting}

\subsection{子集卷积}

\begin{lstlisting}
cin >> d; n = 1 << d;
REP(i, 0, n-1) cin >> a[__builtin_popcount(i)][i];
REP(i, 0, n-1) cin >> b[__builtin_popcount(i)][i];
REP(i, 0, d) fmt(a[i]), fmt(b[i]);
REP(i, 0, n-1) REP(j, 0, d) REP(k, 0, d-j)
	c[j+k][i] += 1ll * a[j][i] * b[k][i];
REP(i, 0, d) ifmt(c[i]);
REP(i, 0, n-1)
	cout << c[__builtin_popcount(i)][i] << " \n"[i==n-1];
\end{lstlisting}

\subsection{FWT}

\begin{lstlisting}
constexpr array<Mint, 4> OR1  = {    1,     0,     1,      1};
constexpr array<Mint, 4> OR2  = {    1,     0,    -1,      1};
constexpr array<Mint, 4> AND1 = {    1,     1,     0,      1};
constexpr array<Mint, 4> AND2 = {    1,    -1,     0,      1};
constexpr array<Mint, 4> XOR1 = {    1,     1,     1,     -1};
constexpr array<Mint, 4> XOR2 = {1_M/2, 1_M/2, 1_M/2, -1_M/2};
constexpr void FWT(int n, Mint* a, array<Mint, 4> t) {
	for (int x = 2; x <= n; x <<= 1) {
		int k = x >> 1;
		for (int i = 0; i < n; i += x) {
			for (int j = 0; j < k; j++) {
				auto tmp0 = a[i+j] * t[0] + a[i+j+k] * t[1];
				auto tmp1 = a[i+j] * t[2] + a[i+j+k] * t[3];
				a[i + j] = tmp0, a[i + j + k] = tmp1;
			}
		}
	}
}
\end{lstlisting}

\section{二维计算几何}

\subsection{凸包}

\begin{lstlisting}
using pt = array<i64, 2>;
pt operator+ (pt a, pt b) { return {a[0] + b[0], a[1] + b[1]}; }
pt operator- (pt a, pt b) { return {a[0] - b[0], a[1] - b[1]}; }
i64 operator* (pt a, pt b) { return a[0] * b[0] + a[1] * b[1]; }
i64 operator^ (pt a, pt b) { return a[0] * b[1] - a[1] * b[0]; }
pt operator- (pt a) { return {-a[0], -a[1]}; }
db abs(pt a) { return __builtin_hypot(a[0], a[1]); }
i64 sq(pt a) { return a[0] * a[0]+ a[1] * a[1]; }
int check(pt x, pt y, pt z) { return ((y - x) ^ (y - z)) < 0; }
vector<int> work(const vector<pt> &p) {
	if (!p.size()) return {};
	int n = p.size(), top = -1;
	vector<int> ind(n), st(n+1), vis(n);
	REP(i, 0, n-1) ind[i] = i;
	ranges::sort(ind, [&] (int i, int j) { return p[i] < p[j]; });
	st[++top] = ind[0];
	REP(i, 0, n-1) {
		while (top >= 1 && !check(p[st[top-1]], p[st[top]], p[ind[i]]))
		vis[st[top]] = 0, top --;
		st[++top] = ind[i]; vis[ind[i]] = 1;
	}
	int siz = top;
	REV(i, n-2, 0) {
		if (vis[ind[i]]) continue;
		while (top > siz && !check(p[st[top-1]], p[st[top]], p[ind[i]]))
		vis[st[top]] = 0, top --;
		st[++top] = ind[i]; vis[ind[i]] = 1;
	}
	return st.resize(top), st;
}
\end{lstlisting}

\section{字符串}

\subsection{manacher}

\begin{lstlisting}
void manacher(int sz) {
	int R = 0, mid = 0;
	REP(i, 1, sz-1) {
		p[i] = R > i ? min(p[2*mid-i], R-i) : 1;
		while (s1[i+p[i]] == s1[i-p[i]]) p[i]++;
		if (i + p[i] > R)
		R = i + p[i], mid = i;
	}
}
int is_pal(int l, int r) {
	return p[l+r] > r - l;
}
/*
0 1 2 3 4 5 6 7 8 9 ...... [index]
  1   1   1   1   1   11  1   1   1   1   1
^ . a . b . c . b . a . a . b . c . b . a . @
    2   2   6   2   2   2   2   6   2   2
*/
\end{lstlisting}

\section{数据结构}

\subsection{[后缀加+前缀求和]树状数组}

\begin{lstlisting}
void Add(i64 p, i64 v) {
	for (int x = p; x <= n; x += x&-x)
		ta[x] += v, tb[x] += p * v;
}
i64 Query(i64 p, i64 ans = 0) {
	for (int x = p; x; x -= x&-x)
		ans += (p+1) * ta[x] - tb[x];
	return ans;
}
void A(int l, int r, i64 v) {
	Add(l, v); Add(r+1, -v);
}
i64 Q(int l, int r) {
	return Query(r) - Query(l-1);
}
\end{lstlisting}

\subsection{二维树状数组}

\begin{lstlisting}
struct T {
	int tr[N][N];
	void Add(int p, int q, int v) {
		for (int x = p; x <= n; x += x&-x)
		for (int y = q; y <= n; y += y&-y)
		tr[x][y] += v;
	}
	int Query(int p, int q, int ans = 0) {
		for (int x = p; x >= 1; x -= x&-x)
		for (int y = q; y >= 1; y -= y&-y)
		ans += tr[x][y];
		return ans;
	}
} T, Tx, Txy, Ty;
void Add(int x, int y, int v) {
	T.Add(x, y, v);
	Tx.Add(x, y, v * x);
	Ty.Add(x, y, v * y);
	Txy.Add(x, y, v * x * y);
}
int Query(int x, int y) {
	return Txy.Query(x, y)
	- Tx.Query(x, y) * (y + 1)
	- Ty.Query(x, y) * (x + 1)
	+ T.Query(x, y) * (x*y + x + y + 1);
}
// (a, b) ~ (c, d)
void A(int a, int b, int c, int d, int v) {
	c ++, d ++;
	Add(c, d, v);
	Add(a, b, v);
	Add(a, d, -v);
	Add(c, b, -v);
}
int Q(int a, int b, int c, int d) {
	a --, b --;
	return Query(c, d)
	+ Query(a, b)
	- Query(a, d)
	- Query(c, b);
}
\end{lstlisting}

\subsection{树状数组select}

\begin{lstlisting}
// 最后一个 前缀和 <= k 的位置
int select(i64 k) {
	int x = 0; i64 cur = 0;
	for (int i = 1<<__lg(n); i; i /= 2) {
		if (x + i <= n && cur + tree[x+i] <= k) {
			x += i; cur = cur + tree[x];
		}
	}
	return x;
}
\end{lstlisting}

\subsection{单点修改线段树}

\begin{lstlisting}
struct Info { };
Info operator+ (const Info &a, const Info &b) {}
Info info[N<<2], init[N];
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
inline void PushUp(int x) {
	info[x] = info[ls(x)] + info[rs(x)];
}
void Build(int x, int l, int r) {
	if (l >= r) return info[x] = init[l], void ();
	int mid = (l+r) >> 1;
	Build(ls(x), l, mid);
	Build(rs(x), mid+1, r);
	PushUp(x);
}
void Modify(int x, int l, int r, int pos, const Info &val) {
	if (l == pos && pos == r) {
		return info[x] = val, void ();
	}
	if (pos < l || pos > r) return;
	int mid = (l+r) >> 1;
	if (pos <= mid) Modify(ls(x), l, mid, pos, val);
	if (pos > mid) Modify(rs(x), mid+1, r, pos, val);
	PushUp(x);
}
Info Query(int x, int l, int r, int L, int R) {
	if (L <= l && r <= R) return info[x];
	int mid = (l+r) >> 1;
	if (R <= mid) return Query(ls(x), l, mid, L, R);
	if (mid < L) return Query(rs(x), mid+1, r, L, R);
	return Query(ls(x), l, mid, L, R) + Query(rs(x), mid+1, r, L, R);
}
#undef ls
#undef rs
\end{lstlisting}

\subsection{区间修改懒标记线段树}

\begin{lstlisting}
struct Tag {
	void apply(const Tag &t) {}
	static Tag Id() {}
};
struct Info {
	void apply(const Tag &t) {}
};
Info operator+ (const Info &a, const Info &b) {}
Info info[N<<2], init[N]; Tag tag[N<<2];
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
inline void PushUp(int x) {
	info[x] = info[ls(x)] + info[rs(x)];
}
inline void Apply(int x, const Tag &val) {
	info[x].apply(val); tag[x].apply(val);
}
void PushDown(int x) {
	Apply(ls(x), tag[x]);
	Apply(rs(x), tag[x]);
	tag[x] = Tag::Id();
}
void Build(int x, int l, int r) {
	tag[x] = Tag::Id();
	if (l >= r) return info[x] = init[l], void ();
	int mid = (l+r) >> 1;
	Build(ls(x), l, mid);
	Build(rs(x), mid+1, r);
	PushUp(x);
}
void Modify(int x, int l, int r, int pos, const Info &val) {
	if (l == pos && pos == r) return info[x] = val, void ();
	int mid = (l+r) >> 1;
	PushDown(x);
	if (pos <= mid) Modify(ls(x), l, mid, pos, val);
	if (pos > mid) Modify(rs(x), mid+1, r, pos, val);
	PushUp(x);
}
void Add(int x, int l, int r, int L, int R, const Tag &val) {
	if (L <= l && r <= R) return Apply(x, val), void ();
	int mid = (l+r) >> 1;
	PushDown(x);
	if (mid >= L) Add(ls(x), l, mid, L, R, val);
	if (R > mid) Add(rs(x), mid+1, r, L, R, val);
	PushUp(x);
}
Info Query(int x, int l, int r, int L, int R) {
	if (L <= l && r <= R) return info[x];
	int mid = (l+r) >> 1;
	PushDown(x);
	if (R <= mid) return Query(ls(x), l, mid, L, R);
	if (mid < L) return Query(rs(x), mid+1, r, L, R);
	return Query(ls(x), l, mid, L, R) + Query(rs(x), mid+1, r, L, R);
}
#undef ls
#undef rs
\end{lstlisting}

\subsection{ST表}

\begin{lstlisting}
int f[N+50][20], n;
void Init() {
	REP(i, 1, __lg(n)) REP(j, 1, n+1-(1<<i))
		f[j][i]=gcd(f[j][i-1],f[j+(1<<(i-1))][i-1]);
}
int Get(int l, int r) {
	int k = __lg(r-l+1);
	return gcd(f[l][k], f[r-(1<<k)+1][k]);
}
\end{lstlisting}

\subsection{FHQ \space Treap}

\begin{lstlisting}
const int N = 2e5+10;
mt19937 rnd(2333);
int root, cnt, x, y, z;
struct hh{ int v, w, size, ls, rs; } tr[N];
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
void pushup(int u){ tr[u].size = 1 + tr[ls(u)].size + tr[rs(u)].size; }
int newnode(int v) { return tr[++cnt] = {v, int(rnd()), 1}, cnt; }
int merge(int x, int y) {
	if (!x || !y) return x ^ y;
	if (tr[x].w > tr[y].w) return rs(x) = merge(rs(x), y), pushup(x), x;
	return ls(y) = merge(x, ls(y)), pushup(y), y;
}
void split(int u, int v, int &x, int &y) { // <= w | > w
	if (!u) return x = y = 0, void();
	if (tr[u].v <= v) x = u, split(rs(u), v, rs(u), y);
	else y = u, split(ls(u), v, x, ls(u));
	pushup(u);
}
#undef ls
#undef rs
\end{lstlisting}

\subsection{笛卡尔树}

\begin{lstlisting}
int lc[N], rc[N], s[N], n, p;
void build () { // v: i ; w: a[i] ; root=rc[0]
	for (int i = 1;i <= n;++i) { // 大根堆则是 <
		while (p && (a[s[p]] > a[i])) p--;
		lc[i] = rc[s[p]];
		rc[s[p]] = i;
		s[++p] = i;
	}
}
\end{lstlisting}

\subsection{普通矩阵}

\begin{lstlisting}
template <size_t N, size_t M, typename T = i64>
using Mat = array<array<T, M>, N>;

template <size_t N, size_t M, typename T>
Mat<N, M, T> operator+ (const Mat<N, M, T> &a, const Mat<N, M, T> &b) {
	Mat<N, M, T> res {};
	REP(i, 0, N-1) REP(j, 0, M-1) res[i][j] = a[i][j] + b[i][j];
	return res;
}
template <size_t N, size_t M, typename T>
Mat<N, M, T> operator- (const Mat<N, M, T> &a, const Mat<N, M, T> &b) {
	Mat<N, M, T> res {};
	REP(i, 0, N-1) REP(j, 0, M-1) res[i][j] = a[i][j] - b[i][j];
	return res;
}
template <size_t N, size_t M, size_t K, typename T>
constexpr Mat<N, K, T> operator* (const Mat<N, M, T> &a, const Mat<M, K, T> &b) {
	Mat<N, K, T> res {};
	REP(i, 0, N-1) REP(j, 0, M-1) REP(k, 0, K-1)
		res[i][k] += a[i][j] * b[j][k];
	return res;
}
\end{lstlisting}

\subsection{(max, +)矩阵}

\begin{lstlisting}
template <typename Ty>
constexpr void chmax(Ty &a, Ty b) {
	if (b > a) a = b;
}
template <size_t N, typename T = i64>
using Mat = array<array<T, N>, N>;
template <size_t N, typename T>
constexpr Mat<N, T> operator* (const Mat<N, T> &a, const Mat<N, T> &b) {
	Mat<N, T> res {};
	REP(i, 0, N-1) REP(k, 0, N-1) res[i][k] = -1e16;
	REP(i, 0, N-1) REP(j, 0, N-1) REP(k, 0, N-1)
		chmax(res[i][k], a[i][j] + b[j][k]);
	return res;
}
\end{lstlisting}

\subsection{LCT}

\begin{lstlisting}
const int N = 2e5+10;
int son[N][2], fa[N], rev[N], val[N], sum[N];
bool get(int x, int p = 1) { return son[fa[x]][p] == x; }
void update(int x) {
	sum[x] = val[x] ^ sum[son[x][0]] ^ sum[son[x][1]];
}
int is_root(int x) { return !(get(x) || get(x, 0)); }
void rotate(int x) { // 注意 x y z !!!!!
	int y = fa[x], z = fa[y], b = get(x);
	if (!is_root(y)) son[z][get(y)] = x;
	son[y][b] = son[x][!b], son[x][!b] = y;
	fa[son[y][b]] = y, fa[y] = x, fa[x] = z;
	update(y);
}
void put(int x) {
	if (x) rev[x] ^= 1, swap(son[x][0], son[x][1]);
}
void down(int x) {
	if (rev[x]) put(son[x][0]), put(son[x][1]), rev[x] = 0;
}
void pushdown(int x) {
	if (!is_root(x)) pushdown(fa[x]);
	down(x);
}
void splay(int x) {
	for (pushdown(x); !is_root(x); rotate(x))
		if (!is_root(fa[x]))
			rotate(get(x)^get(fa[x]) ? x : fa[x]);
	update(x);
}
void access(int x) {
	for (int t = 0; x; son[x][1] = t, t = x, x = fa[x]) splay(x);
}
void mkroot(int x) {
	access(x), splay(x), put(x);
}
int find(int x) {
	access(x), splay(x);
	while (son[x][0]) x = son[x][0];
	return splay(x), x;
}
void split(int x, int y) {
	mkroot(x), access(y), splay(y);
}
void link(int x, int y) {
	mkroot(x);
	if(find(y)!=x) fa[x] = y;
}
void cut(int x, int y) {
	mkroot(x);
	if(find(y)==x && fa[y]==x && !son[y][0]){
		fa[y] = son[x][1] = 0;
		update(x);
	}
}
\end{lstlisting}

\begin{lstlisting}
if (ty == 0) {
	split(x, y);
	cout << sum[y] << "\n";
}
if (ty == 1) {
	link(x, y);
}
if (ty == 2) {
	cut(x, y);
}
if (ty == 3) {
	splay(x);
	val[x] = y;
}
\end{lstlisting}

\section{图论}

\subsection{floyd}

\begin{lstlisting}
REP(k, 1, n) REP(x, 1, n) REP(y, 1, n)
	f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
\end{lstlisting}

\subsection{dinic}

\begin{lstlisting}
const i64 INF = 2e16L;
struct Node { int to; i64 cap, flow; };
vector<Node> e;
vector<vector<int>> adj;
vector<int> cur, dis;
int n, s, t;
void init(int nn, int ss = 0, int tt = 0) {
	n = nn, s = ss, t = tt;
	e.clear(); adj.assign(n+1, {});
}
void add(int u, int v, i64 w) {
	adj[u].push_back(e.size());
	e.push_back({v, w, 0});
	adj[v].push_back(e.size());
	e.push_back({u, 0, 0});
}
int bfs() {
	dis.assign(n+1, {});
	cur.assign(n+1, {});
	queue<int> Q;
	for (Q.push(s), dis[s] = 1; Q.size(); ) {
		int u = Q.front(); Q.pop();
		for (auto i : adj[u]) {
			if (!dis[e[i].to] && e[i].cap-e[i].flow)
				dis[e[i].to] = dis[u] + 1, Q.push(e[i].to);
		}
	}
	return dis[t];
}
i64 dfs(int u, i64 flow) {
	if (u == t || !flow) return flow;
	i64 tot = 0, res;
	for (int &id = cur[u]; id < ssize(adj[u]); id ++) {
		int i = adj[u][id];
		if (dis[e[i].to] == dis[u] + 1 && (res = dfs(e[i].to, min(flow, e[i].cap - e[i].flow)))) {
			e[i].flow += res, e[i^1].flow -= res;
			tot += res, flow -= res;
			if (!flow) break;
		}
	}
	return tot;
}
i64 Dinic() {
	i64 ans = 0;
	for (; bfs(); ) ans += dfs(s, INF);
	return ans;
}
\end{lstlisting}

\subsection{费用流 (EK)}

\begin{lstlisting}
const i64 INF = 1e16L;
using pr = pair<i64, int>;
struct Node { int to; i64 vol, flow, cost; };
vector<vector<int>> adj;
vector<int> from, vis;
vector<Node> e;
vector<i64> d, dis;
int n, s, t; i64 F, C;
void init(int nn, int ss, int tt) {
	n = nn, s = ss, t = tt;
	adj.assign(n+1, {});
	e = {{}, {}};
	from.assign(n+1, 0);
	vis.assign(n+1, 0);
	d.assign(n+1, 0);
	dis.assign(n+1, 0);
}
void add(int x, int y, int v, int f) {
	adj[x].push_back(e.size());
	e.push_back({y, v, 0, f});
	adj[y].push_back(e.size());
	e.push_back({x, 0, 0, -f});
}
int spfa() {
	queue<int> Q;
	d.assign(n+1, INF);
	for (d[s] = 0, vis[s] = 1, Q.push(s); Q.size(); ) {
		auto x = Q.front(); Q.pop(); vis[x] = 0;
		for (auto i : adj[x]) {
			if (e[i].vol - e[i].flow && d[e[i].to] > d[x] + e[i].cost) {
				d[e[i].to] = d[x] + e[i].cost;
				from[e[i].to] = i;
				if (!vis[e[i].to]) vis[e[i].to] = 1, Q.push(e[i].to);
			}
		}
	}
	return d[t] < INF;
}
int dij() {
	priority_queue<pr, vector<pr>, greater<pr>> Q;
	dis.swap(d);
	d.assign(n+1, INF);
	vis.assign(n+1, 0);
	from.assign(n+1, 0);
	for (Q.emplace(d[s] = 0, s); Q.size(); ) {
		auto x = Q.top().second; Q.pop();
		if (vis[x]) continue;
		vis[x] = 1;
		for (auto i : adj[x]) {
			const i64 v = e[i].cost + dis[x] - dis[e[i].to];
			if (e[i].vol - e[i].flow && d[e[i].to] > d[x] + v) {
				from[e[i].to] = i;
				Q.emplace(d[e[i].to] = d[x] + v, e[i].to);
			}
		}
	}
	for (int i = 0; i <= n; i ++) d[i] += dis[i];
	return d[t] < INF;
}
array<i64, 2> EK() {
	spfa();
	F = C = 0;
	for (; dij(); ) {
		i64 fl = INF;
		for (int i = from[t]; i; i = from[e[i^1].to])
			fl = min<i64> (e[i].vol - e[i].flow, fl);
		for (int i = from[t]; i; i = from[e[i^1].to])
			e[i].flow += fl, e[i^1].flow -= fl;
		F += fl, C += fl * d[t];
	}
	return {F, C};
}
\end{lstlisting}

\subsection{tarjan(强联通分量)}

\begin{lstlisting}
int dfn[N], low[N], bel[N], st[N], top, cnt, tms;
vector<int> adj[N], scc[N];
void tarjan(int u) {
	dfn[u] = low[u] = ++tms;
	st[++top] = u;
	for (auto v : adj[u]) {
		if (!dfn[v]) {
			tarjan(v);
			chmin(low[u], low[v]);
		}
		else if (!bel[v]) {
			chmin(low[u], dfn[v]);
		}
	}
	if (low[u] == dfn[u]) {
		int z; cnt ++;
		do {
			z = st[top--]; bel[z] = cnt;
			scc[cnt].push_back(z);
		}
		while (z != u);
	}
}
\end{lstlisting}

\subsection{tarjan(边双)}

\begin{lstlisting}
const int N = 5e5L+10;
// to, ind
vector<array<int, 2>> adj[N];
vector<int> bcc[N];
int dfn[N], low[N], st[N], bel[N], top, n, m, cnt, tt;
void tarjan(int u, int in) {
	low[u] = dfn[u] = ++tt;
	st[++top] = u;
	for (auto [v, id] : adj[u]) {
		if (id == in) continue;
		if (!dfn[v]) {
			tarjan(v, id);
			chmin(low[u], low[v]);
		}
		else {
			chmin(low[u], dfn[v]);
		}
	}
	if (dfn[u] == low[u]) {
		cnt ++;
		int z;
		do {
			z = st[top--];
			bcc[cnt].push_back(z);
			bel[z] = cnt;
		}
		while (z != u);
	}
}
\end{lstlisting}

\subsection{tarjan(点双)}

\begin{lstlisting}
int dfn[N], low[N], st[N], bel[N], cut[N], top, tms, cnt;
vector<int> adj[N], bcc[N];
void tarjan(int u, int fa) {
	dfn[u] = low[u] = ++tms;
	st[++top] = u;
	int ch = 0;
	for (auto v : adj[u]) {
		if (!dfn[v]) {
			tarjan(v, u);
			chmin(low[u], low[v]);
			if (low[v] >= dfn[u]) {
				if (++ch > 1 && fa) cut[u] = 1;
				int z; cnt ++;
				do {
					z = st[top--];
					bel[z] = cnt;
					bcc[cnt].push_back(z);
				}
				while (z != v);
				bcc[cnt].push_back(u);
			}
		}
		else chmin(low[u], dfn[v]);
	}
	if (!fa && !ch) {
		bcc[++cnt] = {u}; // 特判独立点
	}
}
\end{lstlisting}

\section{Misc}

\subsection{cout精度}

\begin{lstlisting}
cout.setf(ios::fixed); cout.precision(15);
\end{lstlisting}

\subsection{int128}

\begin{lstlisting}
istream& operator>>(istream& cin, i128& x) {
	i128 w = 1, v = 0;
	string s; cin >> s;
	for (auto i : s) {
		if (i == '-') w = -1;
		else v = v * 10 + (i - '0');
	}
    return x = w * v, cin;
}
ostream& operator<<(ostream& cout, i128 x) {
	if (x == 0) return cout << 0;
	if (x < 0) cout << '-', x = -x;
	string s;
	while (x) s += '0' + x % 10, x /= 10;
	reverse(s.begin(), s.end());
	return cout << s;
}
\end{lstlisting}

\subsection{上取整下取整}
i64 ceilDiv(i64 n, i64 m) {
	return n >= 0 ? (n + m - 1) / m : n / m;
}
i64 floorDiv(i64 n, i64 m) {
	return n >= 0 ? n / m : (n - m + 1) / m;
}
\begin{lstlisting}
cout.setf(ios::fixed); cout.precision(15);
\end{lstlisting}

\subsection{mmap映射stdin}

\begin{lstlisting}
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// int fd = open("*.in", O_RDONLY);
int fd = 0; // stdin
struct stat state;
fstat(fd, &state);
int len = state.st_size;
char* addr = (char *) mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
\end{lstlisting}

\subsection{read()}

\begin{lstlisting}
int read() { // 换成 getchar_unlocked 可加快速度
	int x = 0, w = 1, ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') w = -1;
	for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';
	return x * w;
}
\end{lstlisting}

\subsection{随机相关}

\begin{lstlisting}
mt19937_64 rd(chrono::system_clock::now().time_since_epoch().count());
\end{lstlisting}

\subsection{二进制相关}

\point{遍历所有含1个数相同的数}

\begin{lstlisting}
u64 nxt(u64 x) {
	u64 b = x&(~x+1);
	u64 t = x + b;
	u64 c = t&(~t+1);
	u64 m = (c/b>>1)-1;
	return t | m;
}
/*
000111  <== enter
001011
001101
001110
......
110010
110100
111000
...... <== exit when ui64(-1)
*/
\end{lstlisting}

\point{builtin相关函数}

\texttt{\_\_builtin\_popcount(x)}: 返回x的二进制表示中1的个数。(适用于 \texttt{unsigned int})

\texttt{\_\_builtin\_popcountll(x)} 则是适用于unsigned i64

\begin{lstlisting}
int count = __builtin_popcount(65535u); // count的值为16
\end{lstlisting}

\texttt{\_\_builtin\_clz(x)}: 返回x的二进制表示中从最高位开始连续0的个数，如果x的值为0，则返回所在类型的位宽。

\begin{lstlisting}
int count = __builtin_clz(0xf00000u); // count的值为8
\end{lstlisting}

\texttt{\_\_builtin\_ctz(x)}: 返回x的二进制表示中从最低位开始连续0的个数，如果x的值为0，则返回所在类型的位宽。

\begin{lstlisting}
int count = __builtin_ctz(0xf0u); // count的值为4
\end{lstlisting}

\texttt{\_\_builtin\_parity(x)}: 返回x的二进制表示中1的个数是否为奇数，是则返回1，否则返回0。

\begin{lstlisting}
int parity = __builtin_parity(0xfu); // parity的值为1
\end{lstlisting}

\texttt{\_\_builtin\_bswap16(x)}: 将x的二进制表示中的16位进行字节交换。
\begin{lstlisting}
unsigned short y = __builtin_bswap16(0xaabb);
//                             y的值为0xbbaa
\end{lstlisting}

\texttt{\_\_builtin\_bswap32(x)}: 将x的二进制表示中的32位进行字节交换。

\begin{lstlisting}
u32 y = __builtin_bswap32(0xaabbccddU);
//                           y的值为0xddccbbaa
\end{lstlisting}

\texttt{\_\_builtin\_bswap64(x)}: 将x的二进制表示中的64位进行字节交换。
\begin{lstlisting}
u64 y = __builtin_bswap64(0xaabbccddeeff1122ULL);
//                           y的值为0x2211ffeeddccbbaa
\end{lstlisting}

\subsection{<ext/pbds/>}

\point{哈希表}

\begin{lstlisting}
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>

__gnu_pbds::gp_hash_table<int, int> mp1; // 拉链法
__gnu_pbds::cc_hash_table<int, int> mp2; // 探测法
\end{lstlisting}

\point{平衡树}

\begin{lstlisting}
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

template<class T, class TT = __gnu_pbds::null_type>
using ordered_set = __gnu_pbds::tree<
	T, TT, std::less<T>,
	__gnu_pbds::rb_tree_tag,
	// rb_tree_tag 红黑树
	// splay_tree_tag splay树
	__gnu_pbds::tree_order_statistics_node_update
	>;
\end{lstlisting}

\texttt{order\_of\_key(x)}  返回比 x 小的数的数量。

\texttt{find\_by\_order(x)}  返回排名 x 所对应元素的迭代器

\begin{lstlisting}
ordered_set<int> s;
s.insert(...); // 1, 3, 5, 7, 11
REP(i, 0, 6) cout << *s.find_by_order(i) << " "; cout << endl;
// 1, 3, 5, 7, 11, 0, 0
REP(i, 0, 12) cout << s.order_of_key(i) << " "; cout << endl;
// 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5
//   (1)   (3)   (5)   (7)         (11)
\end{lstlisting}

\texttt{split(x,b)} 按照 $x$ 分裂，小于等于 $x$ 的属于当前树，其余的属于 $b$ 树。

\texttt{join(x)} 将两颗树合并。前提是两者值域没有交集。

\point{可并堆}

\begin{lstlisting}
__gnu_pbds::priority_queue<int, less<int>, // 使用greater则是小根堆
__gnu_pbds::pairing_heap_tag> q;
// pairing_heap_tag     配对堆
// binomial_heap_tag    二项堆
// rc_binomial_heap_tag 冗余计数二项堆
// binary_heap_tag      二叉堆
// thin_heap_tag        斐波那契堆
\end{lstlisting}

\texttt{join(b)}: 把优先队列 b 合并进来并把 b 清空

\point{rope}

\begin{lstlisting}
#include <ext/rope>
__gnu_cxx::rope<char> rp = "1234";
rp.append("abcd");       // 1234abcd
rp.append('$');          // 1234abcd$
rp.replace(3, 2, "***"); // 123***bcd$
rp.append(4, ';');       // 123***bcd$;;;;
rp.erase(2, 3);          // 12*bcd$;;;;
rp.insert(6, 3, '!');    // 12*bcd!!!$;;;;
\end{lstlisting}

\subsection{多项式输出}

\begin{lstlisting}
i64 n; cin >> n; vl xishu(n+1);
REV(i, n, 0) cin >> xishu[i];
REV(i, n, 0) {
	if (xishu[i] == 0) continue;
	else if (xishu[i] < 0)
	cout << '-', xishu[i] = -xishu[i];
	else if (xishu[i] > 0 && i != n)
	cout << '+';
	if (xishu[i] != 1 || i == 0)
	cout << xishu[i];
	if (i > 1) cout << 'x' << '^' << i;
	else if (i == 1) cout << 'x';
} cout << endl;
\end{lstlisting}

\subsection{日期}

\begin{lstlisting}
int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
struct Date {
	int year, month, day;
};
//判闰年
inline int leap(int year) {
	return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
}
//判合法性
inline int legal(Date a) {
	if (a.month < 0 || a.month>12)
	return 0;
	if (a.month == 2)
	return a.day > 0 && a.day <= 28 + leap(a.year);
	return a.day > 0 && a.day <= days[a.month - 1];
}
//比较日期大小
inline int datecmp(Date a, Date b) {
	if (a.year != b.year)
	return a.year - b.year;
	if (a.month != b.month)
	return a.month - b.month;
	return a.day - b.day;
}
//返回指定日期是星期几
int weekday(Date a) {
	int tm = a.month >= 3 ? (a.month - 2) : (a.month + 10);
	int ty = a.month >= 3 ? a.year : (a.year - 1);
	return (ty + ty / 4 - ty / 100 + ty / 400 + (int)(2.6 * tm - 0.2) + a.day) % 7;
}
//日期转天数偏移
int date2int(Date a) {
	int ret = a.year * 365 + (a.year - 1) / 4 - (a.year - 1) / 100 + (a.year - 1) / 400;
	days[1] += leap(a.year);
	for (int i = 0; i < a.month - 1; ret += days[i++]);
	days[1] = 28;
	return ret + a.day;
}
//天数偏移转日期
Date int2date(int a) {
	Date ret = {0, 0, 0};
	ret.year = a / 146097 * 400;
	for (a %= 146097; a >= 365 + leap(ret.year); a -= 365 + leap(ret.year), ret.year++);
	days[1] += leap(ret.year);
	for (ret.month = 1; a >= days[ret.month - 1]; a -= days[ret.month - 1], ret.month++);
	days[1] = 28;
	ret.day = a + 1;
	return ret;
}
\end{lstlisting}

\begin{lstlisting}
auto E_is_leap = [&] (int y) -> int {
	if (y % 400 == 0) return 1;
	if (y % 100 == 0) return 0;
	if (y % 4 == 0) return 1;
	return 0;
};
vector<int> E_days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
auto E_days_in_month = [&] (int y, int m) -> int {
	assert(1 <= m && m <= 12);
	if (m == 2 && E_is_leap(y)) return E_days[m] + 1;
	return E_days[m];
};
vector<int> E_days_presum(13);
REP(i, 1, 12) {
	E_days_presum[i] = E_days_presum[i-1] + E_days[i];
}
auto E_days_before_month = [&] (int y, int m) -> int {
	if (E_is_leap(y) && m >= 3) return E_days_presum[m-1] + 1;
	return E_days_presum[m-1];
};
auto E_days_before_day = [&] (int y, int m, int d) {
	return E_days_before_month(y, m) + d - 1;
};
auto E_days_before_year = [&] (int y) {
	y --;
	return y*365 + y/4 - y/100 + y/400;
};
auto E_get_ord = [&] (int y, int m, int d) {
	return E_days_before_year(y) + E_days_before_day(y, m, d);
};
constexpr i64 E_seconds_in_day = 1ll * 24 * 60 * 60;
auto E_get_ts = [&] (int Y, int m, int d, int H, int M, int S) -> i64 {
	return E_get_ord(Y, m, d) * E_seconds_in_day
	+ 1ll * 60 * 60 * H
	+ 1ll * 60 * M
	+ 1ll * S;
};
// cout << E_get_ts(2024, 11, 11, 0, 0, 0)
//	  - E_get_ts(1970, 1, 1, 0, 0, 0) << endl;
auto M_is_leap = [&] (int y) -> int {
	if (y % 1000 == 0) return 1;
	if (y % 100 == 0) return 0;
	if (y % 10 == 0) return 1;
	if (y % 2 == 1) return 1;
	return 0;
};
auto M_days_in_month = [&] (int y, int m) -> int {
	assert(1 <= m && m <= 24);
	if (m == 24 && M_is_leap(y)) return 28;
	if (m % 6 == 0) return 27;
	return 28;
};
vector<int> M_days = {0, 28, 28, 28, 28, 28, 27, 28, 28, 28, 28, 28, 27, 28, 28, 28, 28, 28, 27, 28, 28, 28, 28, 28, 27};
vector<int> M_days_presum(25);
REP(i, 1, 24) {
	M_days_presum[i] = M_days_presum[i-1] + M_days[i];
}
auto M_days_before_month = [&] (int y, int m) -> int {
	return M_days_presum[m-1];
};
auto M_days_before_day = [&] (int y, int m, int d) {
	return M_days_before_month(y, m) + d - 1;
};
auto M_days_before_year = [&] (int y) {
	y --;
	return (y+1)*669 - y/2 + y/10 - y/100 + y/1000;
};
auto M_get_ord = [&] (int y, int m, int d) {
	return M_days_before_year(y) + M_days_before_day(y, m, d);
};
constexpr i64 M_seconds_in_day = 1ll * 24 * 60 * 60;
auto M_get_ts = [&] (int Y, int m, int d, int H, int M, int S) -> i64 {
	return M_get_ord(Y, m, d) * M_seconds_in_day
	+ 1ll * 60 * 60 * H
	+ 1ll * 60 * M
	+ 1ll * S;
};
auto M_ord_to_ymd = [&] (int ts) -> array<int, 3> {
	int year = int(floor(db(ts)/668.59L));
	if (ts <= M_days_before_year(year)) year --;
	else if (ts > M_days_before_year(year+1)) year ++;
	ts -= M_days_before_year(year);
	int month = ts / 28 + 1;
	if (ts <= M_days_before_month(year, month)) month --;
	else if (month < 24 && ts > M_days_before_month(year, month+1))
	month ++;
	ts -= M_days_before_month(year, month);
	return {year, month, ts};
};
constexpr db _1SOL = 88775.244147L;  // unit: terrestrial second
constexpr db _M2EC = _1SOL/86400.L;  // 1sol / 1day
constexpr db _E2MC = 86400.L/_1SOL;  // 1day / 1sol
auto E2M = [&] (int Y, int m, int d, int H, int M, int S) -> array<int, 6> {
	db E_ts = E_get_ts(Y, m, d, H, M, S)
	- E_get_ts(1609, 3, 11, 18, 40, 34);
	db M_ts = E_ts / _1SOL;
	db M_time = fmodl(M_ts, 1.L);
	db M_date = M_ts - M_time + 1.L;
	M_time *= M_seconds_in_day;
	auto [x, y, z] = M_ord_to_ymd(M_date);
	int M_time_int = int(M_time);
	int c = M_time_int % 60;
	M_time_int /= 60;
	int b = M_time_int % 60;
	M_time_int /= 60;
	int a = M_time_int;
	return {x, y, z, a, b, c};
};
char tmp;
int Y, m, d, H, M, S;
cin >> Y >> tmp >> m >> tmp >> d;
cin >> H >> tmp >> M >> tmp >> S;
auto [x, y, z, a, b, c] = E2M(Y, m, d, H, M, S);
printf("%04d-%02d-%02d %02d:%02d:%02d\n", x, y, z, a, b, c);
\end{lstlisting}

\subsection{快速排序}

\begin{lstlisting}
mt19937 rnd(random_device{} ());
static void qs(int l, int r) {
	if (l >= r) return;
	swap(a[l], a[l + rnd() % (r-l+1)]);
	int pivot = a[l], i = l, j = r;
	while (i < j) {
		while (i < j && a[j] > pivot) --j;
		if (i < j) a[i++] = a[j];
		while (i < j && a[i] < pivot) ++i;
		if (i < j) a[j--] = a[i];
	}
	a[i] = pivot; qs(l, i-1); qs(i+1, r);
}
\end{lstlisting}

\subsection{火车头精简版}

\begin{lstlisting}
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
#pragma GCC optimize("inline")
#pragma pack(1)
\end{lstlisting}

\subsection{导数积分}

\textbf{
\small\bfseries
\begin{align*}
\left(\frac{u}{v}\right)' &= \frac{u'v-uv'}{v^2}  &  (\arctan (x))' &= \frac{1}{1+x^2}                    & (\mathrm{arcsinh} (x))' &= \frac{1}{\sqrt{1+x^2}}               \\
(a^x)' &= (\ln a)a^x                              &  (\mathrm{arccot} (x))' &= -\frac{1}{1+x^2}           & (\mathrm{arccosh} (x))' &= \frac{1}{\sqrt{x^2-1}}               \\
(\tan (x))' &= \sec^2 (x)                         &  (\mathrm{arcsec} (x))' &= \frac{1}{|x|\sqrt{x^2-1}}  & (\mathrm{arctanh} (x))' &= \frac{1}{1-x^2}                      \\
(\cot (x))' &= -\csc^2 (x)                        &  (\mathrm{arccsc} (x))' &= -\frac{1}{|x|\sqrt{x^2-1}} & (\mathrm{arccoth} (x))' &= \frac{1}{1-x^2}                      \\
(\sec (x))' &= \tan (x) \sec (x)                  &  (\tanh (x))' &= \mathrm{sech}^2 (x)                  & (\mathrm{arcsech} (x))' &= -\frac{1}{x\sqrt{1-x^2}}             \\
(\csc (x))' &= -\cot (x) \csc (x)                 &  (\coth (x))' &= -\mathrm{csch}^2 (x)                 & (\mathrm{arccsch} (x))' &= -\frac{1}{|x|\sqrt{1+x^2}}           \\
(\arcsin (x))' &= \frac{1}{\sqrt{1-x^2}}          &  (\mathrm{sech} (x))' &= -\mathrm{sech} (x) \tanh (x) &                         &                                       \\
(\arccos (x))' &= -\frac{1}{\sqrt{1-x^2}}         &  (\mathrm{csch} (x))' &= -\mathrm{csch} (x) \coth (x) &                         &                                       \\
\end{align*}
}

{
\Large
$ax^2 + bx + c(a > 0)$

\Large
$$ \int\frac{dx}{ax^2+bx+c} = \begin{cases}
	\frac{2}{\sqrt{4ac-b^2}}\arctan\frac{2ax+b}{\sqrt{4ac-b^2}}+C & (b^2 < 4ac) \\
	\frac{1}{\sqrt{b^2-4ac}}\ln\left|\frac{2ax+b-\sqrt{b^2-4ac}}{2ax+b+\sqrt{b^2-4ac}}\right|+C & (b^2 > 4ac)
\end{cases} $$

$$ \int\frac{x}{ax^2+bx+c}dx = \frac{1}{2a}\ln|ax^2+bx+c|-\frac{b}{2a}\int\frac{dx}{ax^2+bx+c} $$

}

\subsection{STL 积分/求和}

{
\Large
$$ \int_0^1 t^{x-1}(1-t)^{y-1}\,dt = \mathrm{beta}(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)} $$

$$ \int_0^{+\infty} t^{num-1}e^{-t}\,dt = \mathrm{tgamma}(num) = e^{\mathrm{lgamma}(num)}$$

$$ \int_0^{phi} \frac{d\theta}{\sqrt{1-k^2\sin^2\theta}} = \mathrm{ellint\_1}(k,phi) $$

$$ \int_0^{phi} \sqrt{1-k^2\sin^2\theta}\,d\theta = \mathrm{ellint\_2}(k,phi) $$

$$ \int_{num}^{+\infty} \frac{e^{-t}}{t}\,dt = -\mathrm{expint}(-num) $$

$$ \sum_{n=1}^{+\infty} n^{-num} = \mathrm{riemann\_zeta}(num) $$

$$ \frac{2}{\sqrt{\pi}}\int_0^{arg} e^{-t^2}\,dt = \mathrm{erf}(arg) $$

$$ J_{\alpha} (x) = \sum_{m = 0}^{\infty} \frac{(-1)^m}{m ! \Gamma (m + \alpha + 1)} \left(\frac{x}{2}\right) ^ {(2 m + \alpha)} = \mathrm{jn} (\alpha, x) $$

$$ Y_{\alpha} (x) = \frac{J_{\alpha} (x) \cos (\alpha \pi) - J_{ - \alpha} (x)}{\sin (\alpha \pi)} = \mathrm{yn} (\alpha, x) $$

}

\subsection{其他公式}

{
\Large
$$ d(i \cdot j) = \sum_{x | i} \sum_{y | j} [\gcd (x, y) = 1] = \sum_{p \mid \gcd (i, j)} \mu (p) \cdot d (\frac{i}{p}) \cdot d (\frac{j}{p}) $$

$$ \epsilon (x) = \sum \limits_{d \mid x} \mu (d) $$
}

$$
f * g = h \implies g(1) * S(n) = \sum_{i = 1}^{n} h(i) - \sum_{i = 2}^{n} g(i) S(\left \lfloor \frac{n}{i} \right \rfloor)
$$

$$
f = g * h \implies h(p ^ c) = f(p ^ c) - \sum_{i = 1}^{c} g(p ^ i) \cdot h(p ^ {c-i})
$$

\subsection{bashrc}

\begin{lstlisting}
mk() { local F="$1" ; shift ; g++ "$F.cpp" -o "$F" "$@"; }
ulimit -s 1048576
ulimit -v 1048576
\end{lstlisting}

\subsection{Xor \space Shift}

\begin{lstlisting}
u64 xorshift(u64 x) { x ^= x << 13; x ^= x >> 7; x ^= x << 17; return x; }
u32 xorshift(u32 x) { x ^= x << 13; x ^= x >> 17; x ^= x << 5; return x; }
\end{lstlisting}

\subsection{质数表}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
2 & 3 & 5 & 7 & 11 & 13 & 17 & 19 & 23 & 29\\
\hline
31 & 37 & 41 & 43 & 47 & 53 & 59 & 61 & 67 & 71\\
\hline
73 & 79 & 83 & 89 & 97 & 101 & 103 & 107 & 109 & 113\\
\hline
127 & 131 & 137 & 139 & 149 & 151 & 157 & 163 & 167 & 173\\
\hline
179 & 181 & 191 & 193 & 197 & 199 & 211 & 223 & 227 & 229\\
\hline
233 & 239 & 241 & 251 & 257 & 263 & 269 & 271 & 277 & 281\\
\hline
283 & 293 & 307 & 311 & 313 & 317 & 331 & 337 & 347 & 349\\
\hline
353 & 359 & 367 & 373 & 379 & 383 & 389 & 397 & 401 & 409\\
\hline
419 & 421 & 431 & 433 & 439 & 443 & 449 & 457 & 461 & 463\\
\hline
467 & 479 & 487 & 491 & 499 & 503 & 509 & 521 & 523 & 541\\
\hline
547 & 557 & 563 & 569 & 571 & 577 & 587 & 593 & 599 & 601\\
\hline
607 & 613 & 617 & 619 & 631 & 641 & 643 & 647 & 653 & 659\\
\hline
661 & 673 & 677 & 683 & 691 & 701 & 709 & 719 & 727 & 733\\
\hline
739 & 743 & 751 & 757 & 761 & 769 & 773 & 787 & 797 & 809\\
\hline
811 & 821 & 823 & 827 & 829 & 839 & 853 & 857 & 859 & 863\\
\hline
877 & 881 & 883 & 887 & 907 & 911 & 919 & 929 & 937 & 941\\
\hline
947 & 953 & 967 & 971 & 977 & 983 & 991 & 997 & 1009 & 1013\\
\hline
\end{tabular}


%\subsection{}
%
%\begin{lstlisting}
%
%\end{lstlisting}


\end{document}
